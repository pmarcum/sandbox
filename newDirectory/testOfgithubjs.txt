[{"type":"acro","priority":"1","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         this.startDef=\"-1\";\n         this.endDef=\"-1\";\n         var smallWords =\n           ['aka','al','am','an','and','are','as','at','be','by','do','eg','et','etal','etc',\n            'go','he','ie','if','in','io','is','it','me','my','no','ok','on','or','ox','pi',\n            'qi','so','to','we','xi'];\n         var linkedTo=[];\n         var from=[];\n         var i=0;\n         var j=0;\n         var k=0;\n         var a1=0;\n         var a2=0;\n         var w1=0;\n         var w2=0;\n         var tst='';\n         var t='';\n         var endMatch=-1;\n         var acroPos1=[];\n         var wordsPos1=[];\n         var acroPos2=[];\n         var wordsPos2=[];\n         var acroPos=[];\n         var wordsPos=[];\n         var aPos=[];\n         var wPos=[];\n         var aTmp='';\n         var wTmp='';\n         var dist=[];\n         var alength=[];\n         var acro='';\n         var acroDef='';\n         var fullAcro=false;\n         var twoWordMin=false;\n         var noCherryPicking=true;\n         var noSkippedWords=true;\n         var caseMatch=false;\n         var acroCase=false;\n         var twoChars=false;\n         var notShortWord=false;\n         var notSymbol=false;\n         var startSentence=false;\n// Strip out text starting from startPos to the end of the sentence we're in\n         var txt=text.slice(startPos);\n         var tmp=txt.match(/(?:[\\.\\?\\!])(?:(?: [A-Z])|(?: $)|(?:$))/);\n         if (tmp){txt=txt.slice(0,tmp.index);}\n// filter the text, eliminating everything except alpha-numeric and whitespace\n         tmp=JSON.parse(filterTheText('Aa0 ',txt));\n         txt=tmp[0];\n// Convert text to an array of characters.\n         txt=txt.split('');\n         var txtPos=tmp[1];\n// make another array of same length as txt that assigns a word id to each letter. Any non-alphanumeric characters\n// take on the word ID of the character that is to the left of them.\n         var wordIds=[];\n         wordIds.push(0);\n         for (i=1;i < txt.length;i++){\n           if (txt[i-1].match(/ /) && txt[i].match(/[^ ]/)){\n             wordIds.push(wordIds[i-1]+1);// start new word\n           } else {\n             wordIds.push(wordIds[i-1]);} // retain same word id as prev. character\n         }\n// construct an array similar to wordIds, but one that records the position where the word started rather than\n// a sequence of incrementing id values\n         var wordStarts=[];\n         wordStarts.push(0);\n         for (i=1;i < txt.length;i++){\n           if (txt[i-1].match(/ /) && txt[i].match(/[^ ]/)){\n             wordStarts.push(i);// start new word\n           } else {\n             wordStarts.push(wordStarts[i-1]);} // retain same value as prev. character\n         }\n         for (i=0;i < txt.length-1;i++){\n           if (txt[i].match(/[A-Za-z0-9]/)){\n// get all the text to the right of the ith character\n             tmp=txt.slice(i+1).reduce(function(x1,x2,x3){\n// locate all the matches in the text with this ith character. At this point, the match is case-insensitive\n               if (x2.match(/[A-Za-z0-9]/) && wordStarts[x3+i+1] > wordStarts[i] &&\n               x2.toLowerCase()==txt.slice(i,i+1)[0].toLowerCase()){x1.push(x3+i+1);} return x1;},[]);\n             if (tmp.length > 0){\n               linkedTo.push(tmp);\n               from.push(i);}\n           }\n         }\n// - - - - - - - - - - - - - - - - - - - - - - - -\n         if (linkedTo.length==0){return '';}\n//================================== =\n// Now map out all the possible \"paths\" by which an acronym's letters could be matched up with\n// legitimate characters from preceeding word definitions:\n         for (i=0;i < linkedTo[0].length;i++){\n           if (wordStarts[linkedTo[0][i]]==linkedTo[0][i]){\n             acroPos1.push([linkedTo[0][i]]);\n             wordsPos1.push([from[0]]);}\n         }\n         for (i=1;i < linkedTo.length;i++){// step through each character in the test, from left to right\n           aPos=[];\n           wPos=[];\n           for (j=0;j < linkedTo[i].length;j++){\n             for (k=0;k < acroPos1.length;k++){\n// need to make combinations for each of these with all the acroPos that has been rolled up\n// to this point. In order to be included, the jth value in the ith linkedTo needs to meet\n// the following criteria:\n// * characters associated with the acronym must be all be associated with the same \"word\"  AND occur sequentially.\n// * all definition words must have their first letter involved in the acronym (which may be upper or lowercase).\n// * if there are uppercase letters somewhere in the middle of a word, those letters must also appear the acronym\n//   as well as the first character of that word.\n// * letters other than the first letter and uppercase letters within definition words are allowed so long as the\n//   letter(s) to the left of them in the word are also present in the acronym.\n               aTmp=acroPos1[k];\n               aTmp=aTmp[aTmp.length-1];\n               wTmp=wordsPos1[k];\n               wTmp=wTmp[wTmp.length-1];\n               if ((wordStarts[linkedTo[i][j]]==wordStarts[aTmp] &&// acronym within single word\n                    linkedTo[i][j] ==\n                    aTmp + 1 && // sequential acronym letters\n                    wordStarts[from[i]] < wordStarts[aTmp] && // different location from acronym\n                    from[i] > wTmp) && // char in def must be right of prev char\n                    ((wordStarts[from[i]]==from[i]) || // first letter of a word ... or ...\n                     (txt.slice(from[i],from[i]+1)[0].match(/[A-Z0-9]/) && // is uppercase char or number that ...\n                      wordStarts[from[i]]==wordStarts[wTmp]) || // is part already-represented word ... or...\n                      (from[i]==wTmp + 1))){// is part of sequence w/ one of the above 2 cases\n                   aPos.push(acroPos1[k].concat([linkedTo[i][j]]));\n                   wPos.push(wordsPos1[k].concat([from[i]]));}\n             }\n           }\n           if (aPos.length > 0){\n             acroPos1=acroPos1.concat(aPos);\n             wordsPos1=wordsPos1.concat(wPos);}\n         }\n         acroPos2=[];\n         wordsPos2=[];\n         for (i=0;i < linkedTo[0].length;i++){\n           if (wordStarts[linkedTo[0][i]]==linkedTo[0][i]){\n             wordsPos2.push([linkedTo[0][i]]);\n             acroPos2.push([from[0]]);}\n         }\n         for (i=1;i < linkedTo.length;i++){ // step through each character in the test, from left to right\n           aPos=[];\n           wPos=[];\n           for (j=0;j < linkedTo[i].length;j++){\n             for (k=0;k < acroPos2.length;k++){\n               aTmp=acroPos2[k];\n               aTmp=aTmp[aTmp.length-1];\n               wTmp=wordsPos2[k];\n               wTmp=wTmp[wTmp.length-1];\n               if ((wordStarts[from[i]]==wordStarts[aTmp] && // acronym is one word\n                    from[i]==aTmp + 1 && // sequential acronym letters\n                    wordStarts[linkedTo[i][j]] > wordStarts[aTmp] && // different location from acronym\n                    linkedTo[i][j] > wTmp) && // the next char in def to right of last one\n                    ((wordStarts[linkedTo[i][j]]==linkedTo[i][j]) || // first letter of a word ... or ...\n                     (txt.slice(linkedTo[i][j],linkedTo[i][j]+1)[0].match(/[A-Z0-9]/) && // is uppercase char or number that ...\n                      wordStarts[linkedTo[i][j]]==wordStarts[wTmp]) || // is part of already-represented word ... or ...\n                     (linkedTo[i][j]==wTmp + 1))){// is part of sequence w/ one of the above 2 cases\n                  aPos.push(acroPos2[k].concat([from[i]]));\n                  wPos.push(wordsPos2[k].concat([linkedTo[i][j]]));}\n             }\n           }\n           if (aPos.length > 0){\n             acroPos2=acroPos2.concat(aPos);\n             wordsPos2=wordsPos2.concat(wPos);}\n         }\n// combine the findings from both kinds of searches\n         acroPos=acroPos1.concat(acroPos2);\n         wordsPos=wordsPos1.concat(wordsPos2);\n// We can immediately weed out any 1-element entries:\n         acroPos=acroPos.filter(z => z.length > 1);\n         wordsPos=wordsPos.filter(z => z.length > 1);\n// Now test any found matches to insure compliance with other constraints:\n//  * [fullAcro] each character within the group of chars associated with the acronym must have a counterpart in the def words\n//  * [twoWordMin] there must be at least 2 definition words\n//  * [noCherryPicking] there cannot be any words larger than 3 letters laying between def words\n//  * [noSkippedWords]  there cannot be more than 3 words of length greater than 3 characters between the end of the\n//    definition words and the beginning of the acro\n//  * [caseMatch] If the acronym has a mixture of lower/upper case characters, then there must be an exact case match\n//    to those corresponding letters in the definition words.  Likewise, if the definition words has a mixture of\n//    cases, then the acronym must provide an exact character-to-character case match, with the following exception:\n//    if the only uppercase letter in the definition words is the very first letter (e.g., likely the beginning of\n//    a sentence), and the acronym does NOT have a case-mixture, then a case-match is irrelevant. If the acronym\n//    has all caps or all lowercase characters, a case-match is irrelevant so long as the definition words do\n//    not have a case-mixture (disregarding the case of the first letter in the def. words).\n//  * [acroCase] If the acronym has any uppercase letters, there must be more uppercase than lowercase. If the\n//    acronym has only 2 characters, both must be uppercase if one of them is.\n//  * [twoChars] if the acronym is only 2 letters, special precautions must be taken to insure that it is not just an ordinary\n//    2-letter word (like \"to\" or \"so\" or \"at\"). The 2-letter acronym must either consist of all consonants or\n//    all vowels. Note that this constraint could likely remove viable acronyms from the index, but the risk of\n//    false-positive matches is just too high to accept without imposing such rules.\n//  * [notShortWord] acronym can't be among the hardwired list of common \"small words\" (like \"etc\")\n//  * [notSymbol] acronym can't be mistaken for a chemical symbol (like \"Ne\" or \"He\")\n         for (i=0;i < acroPos.length;i++){\n           wTmp=wordsPos[i].map(z => txt.slice(z,z+1)[0]).join('');\n           aTmp=acroPos[i].map(z => txt.slice(z,z+1)[0]).join('');\n           fullAcro=false;\n           twoWordMin=false;\n           noCherryPicking=true;\n           caseMatch=false;\n           acroCase=false;\n           twoChars=false;\n           notShortWord=false;\n           notSymbol=false;\n           noSkippedWords=true;\n           startSentence=false;\n// get the length of the character grouping associated with the acronym itself by finding in the word ID all matches\n// to the word ID value that the acronym characters have:\n           tmp=wordIds.reduce(function(x1,x2,x3){\n             if (x2==wordIds[acroPos[i][0]] && txt.slice(x3,x3+1)[0].match(/[A-Za-z0-9]/)){x1.push(x2);} return x1;},[]);\n             if (tmp.length==acroPos[i].length){fullAcro=true;}\n// See if an uppercase letter exists in the original text just before or just after the identified acro.  If so, and it was skipped\n// over, then fullAcro gets turned back to false:\n             if (startPos > 0 && text.charAt(txtPos[acroPos[i]]).match(/[A-Z]/)){fullAcro=false;}\n             if (startPos < text.length-1 && text.charAt(txtPos[Math.max(... acroPos[i])]).match(/[A-Z]/)){fullAcro=false;}\n// get a list of all the word IDs associated with the definition words:\n             tmp=wordsPos[i].map(z => wordIds[z]);\n             if (tmp!==undefined && tmp && tmp.length > 0 && ([... new Set(tmp)]).sort().length >= 2){twoWordMin=true;}\n// If these definition word IDs are not consequetive, determine how long the words are that are missing from this list\n             tst=[];\n             if (twoWordMin){\n               for (j=Math.min(... tmp)+1;j < Math.max(... tmp);j++){\n                 if (tmp.indexOf(j)==-1){tst.push(j);}\n               }\n             }\n             for (j=0;j < tst.length;j++){\n               tmp=wordIds.reduce(function(x1,x2,x3){\n                 if (x2==j && txt.slice(x3,x3+1)[0].match(/[A-Za-z0-9]/)){x1.push(x2);} return x1;},[]);\n                 if (tmp.length <= 3){noCherryPicking=false;}\n             }\n// determine the range of characters between the end of the definition words and the acronym:\n             tmp=acroPos[i].length;\n             a1=acroPos[i][tmp-1];\n             w1=wordsPos[i][0];\n             a2=acroPos[i][0];\n             tmp=wordsPos[i].length;\n             w2=wordsPos[i][tmp-1];\n             tmp='';\n             if (wordIds[a1] < (wordIds[w1]-1)){\n               tmp=txt.reduce(function(x1,x2,x3){\n                 if (wordIds[x3] > wordIds[a1] && wordIds[x3] < wordIds[w1]){x1.push(x2);} return x1;},[]);\n                 tmp=tmp.join('').replace(/[^A-Za-z0-9 ]/g,'').replace(/  +/g,' ').trim();\n             } else if (wordIds[w2] < (wordIds[a2]-1)){\n               tmp=txt.reduce(function(x1,x2,x3){\n                 if (wordIds[x3] > wordIds[w2] && wordIds[x3] < wordIds[a2]){x1.push(x2);} return x1;},[]);\n                 tmp=tmp.join('').replace(/[^A-Za-z0-9 ]/g,'').replace(/  +/g,' ').trim();}\n// If any of the in-between words had uppercase letters, then the test is failed:\n             if (tmp.match(/[A-Z]/)){noSkippedWords=false;}\n             tmp =tmp.split(' ');\n             tmp=tmp.filter(z => z.length > 3);// don't count words of 3 characters or less\n             if (tmp.length > 3){noSkippedWords=false;}// if more than 3 substantial words lay between acro and def, fail the test\n// For the below tests, need to determine if the definition words start at the beginning of sentence.\n             if (startPos==0){\n               startSentence=true;\n             } else if (text.slice(0,startPos).trim()==''){\n               startSentence=true;\n             } else if (startPos >= 2 && text.slice(startPos-2,startPos).trim()=='\\.'){\n               startSentence=true;}\n             if (aTmp==wTmp){caseMatch=true;}\n             if (aTmp.match(/^[A-Z0-9]+$/) && wTmp.match(/^[a-z0-9]+$/)){caseMatch=true;}\n// If the definition words is a mix of cases that involves more than a capitalization of the start of a sentence,\n// do definition word characters case-match with the acronym characters?\n             if (startSentence && aTmp.slice(1)==wTmp.slice(1)){caseMatch=true;}\n// check the case of the acronym characters, make sure there is consistency\n             if (aTmp.match(/^[A-Z0-9]+$/) || aTmp.match(/^[a-z0-9]+$/)){acroCase=true;}\n             if (aTmp.match(/[A-Z]/) && aTmp.match(/[a-z]/) && aTmp.match(/[A-Z]/g).length > aTmp.match(/[a-z]/g).length){\n               acroCase=true;}\n// Now check the acronym length:\n             if (aTmp.length > 2){twoChars=true;}\n             if (!twoChars){\n// If the acronym consists of all consonants or of all vowels, then it passes the twoChar test:\n                tmp=acroPos[i].reduce(function(x1,x2,x3){\n                  if (txt.slice(x3,x3+1)[0].match(/[aeiou]/i)){x1.push('v')} else {x1.push('c')};return x1;},[]);\n                  if (tmp.length > 0 && ([... new Set(tmp)]).length==1){twoChars=true;}\n             }\n// Make sure that acronym does not match any of the common short words:\n             if (smallWords.indexOf(aTmp)==-1){notShortWord=true;}\n// Now check that the acronym is not actually a chemical symbol!\n             tmp=xLtr.findIndex(z => z.reg!==undefined && z.symbol!==undefined && z.indx(aTmp,0)!='');\n             if (tmp==-1){notSymbol=true;}\n// Now tally up the scores and see if this acronym candidate failed ANY of the tests:\n             if (!(fullAcro*twoWordMin*noCherryPicking*noSkippedWords*caseMatch*acroCase*twoChars*notShortWord*notSymbol)){\n               acroPos[i]=[-1];\n               wordsPos[i]=[-1];}\n         }\n// Remove any -1 values:\n         acroPos=acroPos.filter(z => z[0]!=-1);\n         wordsPos=wordsPos.filter(z => z[0]!=-1);\n// If by now, there are more than 1 possibility for acronym and corresponding definition, then select whichever has the longest acronym.\n// If the acronym length is the same for all the matches, then select the one for which the words and the acronym are closest together.\n         dist=[];\n         alength=[];\n         for (i=0;i < acroPos.length;i++){\n           tmp=acroPos[i].map(z => txt.slice(z,z+1)[0]).join('');\n           alength.push(tmp.length);\n           if (acroPos[i][0] > wordsPos[i][0]){\n             tmp=wordsPos[i].length;\n             dist.push(txt.slice(wordsPos[i][tmp-1]+1,acroPos[i][0]+1).join('').replace(/[^A-Za-z0-9 ]/g,'').length);\n           } else {\n             tmp=acroPos[i].length;\n             dist.push(txt.slice(acroPos[i][tmp-1]+1,wordsPos[i][0]+1).join('').replace(/[^A-Za-z0-9 ]/g,'').length);}\n         }\n         for (i=0;i < acroPos.length;i++){\n           if (alength[i] < Math.max(... alength)){\n             acroPos[i]=[-1];\n             wordsPos[i]=[-1];\n             alength[i]=-1;\n             dist[i]=-1;}\n         }\n         acroPos=acroPos.filter(z => z[0]!=-1);\n         wordsPos=wordsPos.filter(z => z[0]!=-1);\n         dist=dist.filter(z => z!=-1);\n         alength=alength.filter(z => z!=-1);\n         tmp=dist.findIndex(z => z==Math.min(... dist));// returns the first one to meet criteria\n         acro='';\n         acroDef='';\n         if (tmp!=-1){\n           acroPos=acroPos[tmp];\n           wordsPos=wordsPos[tmp];\n           acro=acroPos.map(z => txt.slice(z,z+1)[0]).join('');\n           tmp=[... new Set(wordsPos.map(z => wordStarts[z]))];\n           tmp=[Math.min(... tmp), Math.max(... tmp)];\n           tmp[1]=tmp[1] + wordStarts.filter(z => z==tmp[1]).length;\n           acroDef=txt.slice(tmp[0],tmp[1]).join('').replace(/[^A-Za-z0-9]/g,' ').trim();\n           this.startDef='' + (txtPos[tmp[0]] + startPos);\n           this.endDef='' + (txtPos[tmp[1]-1] + 1 + startPos);\n           acroDef=acroDef.replace(/  +/,' ').trim();\n           if (acroPos[0] > wordsPos[0]){\n             this.endMatch=\"\" + (txtPos[Math.max(... acroPos)] + 1 + startPos);\n           } else {\n             this.endMatch=this.endDef;}\n           return acro + ' ' + acroDef.replace(/ /g,'\\_');\n         } else {return '';}\n      }"},{"type":"citation","priority":"1","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         this.authors=\"\";\n         this.pubYear=\"\";\n         this.journal=\"\";\n         this.page=\"\";\n         this.volume=\"\";\n         var authors=[];\n         var pubYear='';\n         var journal='';\n         var page='';\n         var volume='';\n         var journalAbb='';\n         var tmp='';\n         var t='';\n         var m='';\n         var t1='';\n         var t2='';\n         var shortCit='';\n// Strip out text starting from startPos\n         text=text.slice(startPos, startPos + 5000);\n// From henceforth, need to preserve character positions because at the end, need to know the actual position\n// of the end of the match to to a bibliographic reference, so that the text can be masked out, etc by the\n// function calling this procedure.\n// to reduce complications in identifying the bibliography, remove any Jr, Sr, I, II, etc from\n         text=text.replace(/([\\, ]+)(jr\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n         text=text.replace(/([\\, ]+)(sr\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n         text=text.replace(/([\\, ]+)(i+\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n// replace \"et al\" in the same way:\n         text=text.replace(/([\\, ]+)(et\\.? *al\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n// replace \"and\" in the same way ... if there is not a comma, force one to be there\n         text=text.replace(/[\\, ]+and[\\, ]+/ig, function(x){return '\\,' + x.slice(1).replace(/[ -~]/g,' ');});\n// replace \"&\" in the same way:\n         text=text.replace(/[\\, ]+\\&[\\, ]+/ig, function(x){return '\\,' + x.slice(1).replace(/[ -~]/g,' ');});\n// Occurances of hypenated names is a problem, like Smith-Jones.  replace such occurances to be \"Smithjones\".\n         text=text.replace(/([A-Z][a-z]+)( *\\- *)([A-Z][a-z]+)/g, function(x,x1,x2,x3){\n           return x1.charAt(0).toUpperCase() + x1.slice(1).toLowerCase() + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');});\n// Occurances of names like O'Smith are a problem. Replace such occurances to be \"Osmith\"\n         text=text.replace(/([A-Za-z]+)( *\\' *)([A-Za-z]+)/g, function(x,x1,x2,x3){\n           return x1.charAt(0).toUpperCase() + x1.slice(1).toLowerCase() + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');})\n// If O'Smith got rendered as O Smith, try to catch and fix that situation as well by turning O Smith into \"Osmith\"\n         text=text.replace(/([A-Z])( *)([A-Z][a-z]+)/g, function(x,x1,x2,x3){\n           return x1 + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');})\n// If there are characters that are all lowercase preceding a set of characters that start with a capital letter,\n// scoot the lowercase characters into the other characters, so that \"van Smith\" becomes \"Vansmith\"\n         text=text.replace(/([\\, ]+)([a-z]{2,5})( *)([A-Z][a-z]+)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5){\n           return x1 + x2.charAt(0).toUpperCase() + x2.slice(1) + x4.toLowerCase() + x5 + x3;});\n// There could be the case that \"van Smith\" was rendered as VanSmith, or that O'Smith rendered as OSmith.  There can\n// only be 1 captial letter per last name, or the below algorithm fails. Need to fix this kind of situation so that VanSmith\n// turns into Vansmith and OSmith into Osmith. To fully cover all bases, find every word that starts with a lower case letter\n// but has an uppercase letter somewhere later in the word, and force all characters to be lowercase except for the first\n// letter, which is forced to be uppercase:\n         text=text.replace(/([\\, ]+)([a-z]+)([A-Z])([A-Za-z]+)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5){\n           return x1 + x2.charAt(0).toUpperCase() + x2.slice(1) + x3.toLowerCase() + x4.toLowerCase() + x5;});\n// And now get any word starting with an uppercase letter but has other uppercase letters somewhere else in the word, turn\n// unto all lower case except for first letter (note that we are about to really mess up any legitimate acronyms, but\n// that's OK because these changes are not permanent to the text\n         text=text.replace(/([\\, ]+)([A-Z]+)([a-z]+)([A-Z])([A-Za-z]*)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5,x6){\n           return x1 + x2.charAt(0) + x2.slice(1).toLowerCase() + x3 + x4.toLowerCase() + x5.toLowerCase() + x6;});\n// Remove any capital letters that stand in isolation -- those are likely to be initials. Note that initials are\n// identified as being uppercase letters followed by a period (with possible white space bracketing the period).\n         text=text.replace(/([\\, ]+)((?:[A-Z] *\\. *){1,5})(\\,? *[12]{0,1})/g, function(x,x1,x2,x3){\n           tmp='\\,' + (x1+x2).slice(1).replace(/[ -~]/g,' ');\n           return tmp + x3.replace(/[^0-9]/g,' ');});\n// Create a regexp that looks for groups of characters that look like references within the text:\n// Name,Name,Name2022,JournalName,000,00 where 000,00 is the volume and page numbers, respectively\n         tmp=/^((?:(?:[A-Z][a-z]+\\,){1,20}(?:[A-Z][a-z]+)?)|(?:[A-Z][a-z]+))/.source +\n               /(?:([12]\\d\\d\\d[abc]{0,1})\\,([A-Z][A-Za-z]{1,100})\\,?(\\d+)\\,(\\d+))/.source;\n         tmp=new RegExp(tmp);\n// OK, now filter the text big-time, removing everything except letters, numbers and commas\n         t=JSON.parse(filterTheText(/\\,/.source, text));\n         m=t[0].match(tmp);\n         authors=[];\n         pubYear='';\n         journal='';\n         volume='';\n         page='';\n         if (m){\n// if the original reference is Smith, A. S., Jones, T. E., and Miller, W. D 2002, Astron. J., 145, 1\n// the filtered view would be Smith,Jones,Miller,2002,AstronJ,145,1 (note that the \"and\" and the initials would have already been\n// removed in a previous step above this \"while\" loop). Therefore, tmp will be (Smith,Jones,Miller)(2002)(AstronJ)(145)(1)\n// extract the publication year:\n           pubYear=m[2].trim().replace(/[^0-9]/g,\"\");\n// extract the volume number:\n           volume=m[4].replace(/^0+/,\"\");//remove any preceding zeros\n// get the page numner, but remove any page ranges.  Any dashes would have already been filtered out\n// and the page number will be the page range smushed together to look like a single number.  go back\n// to unfiltered text to make sure there is no dash in there:\n           t1=t[1][m[1].length + m[2].length + m[3].length + m[4].length - 1] + 1;\n           t2=t[1][m[1].length + m[2].length + m[3].length + m[4].length + m[5].length - 1] + 1;\n           page=text.slice(t1,t2).match(/[0-9]+/)[0].replace(/^0+/,\"\");\n// extract the journal name and convert into the journal abbreviation, but extract from the unfiltered text:\n           t1=t[1][m[1].length + m[2].length - 1] + 1;\n           t2=t[1][m[1].length + m[2].length + m[3].length -1] + 1;\n           journal=text.slice(t1,t2).trim();\n// determine what the full name is for this journal by consulting the xLtr's \"journal\" entries:\n           tmp=xLtr.reduce(function(x1,x2,x3){\n             if (x2.type==\"journal\" && x2.abb!==undefined && x2.indx(journal,0)!=\"\" && parseFloat(x2.endMatch) > x1[1]){\n             x1=[x3,parseFloat(x2.endMatch),x2.indx];} return x1;}, [-1,-1,'']);\n           if (tmp[0]!=-1 && tmp[1]==journal.length){\n             journal=tmp[2];// individual words delimited by _\n           } else {\n// a match to the journal name could not be found. Would be pointless to pass along the journal title\n// words for indexing if some of the words are abbreviations like \"jrnl\" instead of \"journal\".  as a\n// compromise, remove any words that might be abbreviations and keep the rest of the words, delimiting\n// them with _\n             journal=journal.split(\" \").toLowerCase().map(z => z.trim());\n             journal=journal.filter(z => !z.match(/\\./)).join(\"\\_\");}\n// extract the individual authors' last names:\n           authors=m[1].replace(/\\,/g,' ').replace(/  +/g,' ').trim().split(' ');\n// Now that we have the author names and publication year, put together the citation likely to appear in the text\n           shortCit='';\n// Now create a  citation phrase... what this bibliography reference will likely look like in the text. For example, if the bibliography\n// entry is Smith, A.K., Jones, Q. R., and Miller, D. R. 2010, ApJ, 545, 34, then the citation phrase might look like Smith et al 2010 or\n// maybe Smith, Jones & Miller 2010. Use both formats just to be certain.\n           if (authors.length > 3){\n             shortCit=authors[0] + 'etal' + pubYear;\n           } else if (authors.length==3){\n             shortCit=authors[0]+'etal'+pubYear+ '\\|' +\n                        authors[0]+authors[1]+'and'+authors[2]+pubYear + '\\|' +\n                        authors[0] + authors[1] + authors[2] + pubYear;// 3 possibilities\n           } else if (authors.length==2){\n             shortCit=authors[0] + 'and' + authors[1] + pubYear + '\\|' +\n                        authors[0] + authors[1] + pubYear;// 2 possibilities\n           } else if (authors.length==1){\n             shortCit=authors[0] + pubYear;}\n           pubYear=pubYear.replace(/[a-zA-Z]/g,'');\n           this.endMatch='' + (t[1][m[0].length-1] + 1 + startPos);\n           this.authors=([... new Set(authors)]).sort().join('\\_');\n           this.pubYear=\"\"+pubYear;\n           this.journal=journal;\n           this.volume=volume;\n           this.page=page;\n           return shortCit.toLowerCase();\n         } else {\n           return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"21","type":"ra","priority":"1","x":"","xSupp":"","nVals":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           var tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"21","type":"dec","priority":"1","x":"","xSupp":"","nVals":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           var tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])) *(?:(?:hours)|(?:hour)|(?:hrs)|(?:hr)|(?:h)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?( *[\\+\\-]{0,1}) *((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))) *(?:(?:textdegree)|(?:circ)|(?:degrees)|(?:degree)|(?:degs)|(?:deg)|(?:d)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?","nChars":"34","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var tmp=\"\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])) *(?:(?:hours)|(?:hour)|(?:hrs)|(?:hr)|(?:h)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?( *[\\+\\-]{0,1}) *((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))) *(?:(?:textdegree)|(?:circ)|(?:degrees)|(?:degree)|(?:degs)|(?:deg)|(?:d)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?","nChars":"34","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         var tmp=\"\";\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:[0-8][0-9])|(?:[0-9](?![0-9])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"18","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         var tmp=\"\";\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:[0-8][0-9])|(?:[0-9](?![0-9])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"18","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var tmp=\"\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:2[0-3])))([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?([\\+\\-])([0-8][0-9])([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?","nChars":"18","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var tmp=\"\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:2[0-3])))([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?([\\+\\-])([0-8][0-9])([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?","nChars":"18","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos){\n         this.endMatch=\"-1\";\n         var tmp=\"\";\n         var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m){\n           this.endMatch=\"\"+(startPos + m[0].length);\n           tmp=extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy=tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"acoefficient","nChars":"12","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"acoefficients","nChars":"13","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"acoeff","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"acoeffs","nChars":"7","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"einsteincoeff","nChars":"13","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient|*b_*einstein_coefficient","x":"*b_*einstein_coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"einsteincoeffs","nChars":"14","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient|*b_*einstein_coefficient","x":"*b_*einstein_coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"einsteincoefficients","nChars":"20","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient|*b_*einstein_coefficient","x":"*b_*einstein_coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ADC","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_to_digital_converter","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"astar","nChars":"5","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"astars","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atype","nChars":"5","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fnu","nChars":"3","priority":"1","type":"jargon","tIndx":"*ab_flux","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mnu","nChars":"3","priority":"1","type":"jargon","tIndx":"*ab_magnitude","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metal","nChars":"5","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metals","nChars":"6","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metallicity","nChars":"11","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metalicity","nChars":"10","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metalicities","nChars":"12","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metallicities","nChars":"13","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metalicitys","nChars":"11","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metallicitys","nChars":"12","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agn","nChars":"3","priority":"1","type":"jargon","tIndx":"active_*galaxy_nucleus","x":"quasar","xSupp":"active_*galaxy_nucleus<X4>quasar","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agns","nChars":"4","priority":"1","type":"jargon","tIndx":"active_*galaxy_nucleus","x":"quasar","xSupp":"active_*galaxy_nucleus<X4>quasar","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ao","nChars":"2","priority":"1","type":"jargon","tIndx":"adaptive_optics","x":"","xSupp":"adaptive_optics<X4>seeing|diffraction_limited|tip_tilt","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"alp","nChars":"3","priority":"1","type":"jargon","tIndx":"*alpha","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"adu","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"adus","nChars":"4","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dn","nChars":"2","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dns","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"datanumber","nChars":"10","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"datanumbers","nChars":"11","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"aips","nChars":"4","priority":"1","type":"jargon","tIndx":"astronomical_image_processing_system","x":"","xSupp":"astronomical_image_processing_system<X4>radio|data_reduction_processing","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"aor","nChars":"3","priority":"1","type":"jargon","tIndx":"astronomical_observation_request","x":"","xSupp":"","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agb","nChars":"3","priority":"1","type":"jargon","tIndx":"asymptotic_giant_branch_*star","x":"red_giant|mira_variable|*ohir_*star","xSupp":"asymptotic_giant_branch_*star<X4>circumstellar_envelope|maser_emission|thermal_pulse","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agbs","nChars":"4","priority":"1","type":"jargon","tIndx":"asymptotic_giant_branch_*star","x":"red_giant|mira_variable|*ohir_*star","xSupp":"asymptotic_giant_branch_*star<X4>circumstellar_envelope|maser_emission|thermal_pulse","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcoefficient","nChars":"12","priority":"1","type":"jargon","tIndx":"*b_*einstein_coefficient","x":"*a_*einstein_coefficient","xSupp":"*b_*einstein_coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcoefficients","nChars":"13","priority":"1","type":"jargon","tIndx":"*b_*einstein_coefficient","x":"*a_*einstein_coefficient","xSupp":"*b_*einstein_coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos){\n               this.endMatch=\"-1\";\n               var m;\n               var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)){\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');}\n               var endMatch=-1;\n               var rightTst=false;\n               var leftTst=false;\n               var middleTst=true;\n               var capTst=true;\n               if (m){\n                 endMatch=t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx==text.slice(startPos,endMatch+1)){endMatch=endMatch + 1;}\n                 leftTst=true;\n                 rightTst=true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)){\n               ////    leftTst=true;}\n              ////   if (startPos==0){leftTst=true;}\n              ////   if (m[0].length > 5){leftTst=true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)){\n              ////     rightTst=true;}\n              ////   if (text.length < endMatch+1){rightTst=true;}\n              ////   if (m[0].length > 5){rightTst=true;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1){capTst=false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)){capTst=false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))){middleTst=false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))){middleTst=false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)){return \"\";}\n               this.endMatch=\"\"+endMatch;\n               return this.tIndx;}"}]