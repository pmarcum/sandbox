[{"type":"acro","priority":"1","indx":"function(text, startPos) {;this.endMatch=\"-1\";this.startDef=\"-1\";this.endDef=\"-1\";var smallWords =;['aka','al','am','an','and','are','as','at','be','by','do','eg','et','etal','etc',;'go','he','ie','if','in','io','is','it','me','my','no','ok','on','or','ox','pi',;'qi','so','to','we','xi'];var linkedTo=[];var from=[];var i=0;var j=0;var k=0;var a1=0;var a2=0;var w1=0;var w2=0;var tst='';var t='';var endMatch=-1;var acroPos1=[];var wordsPos1=[];var acroPos2=[];var wordsPos2=[];var acroPos=[];var wordsPos=[];var aPos=[];var wPos=[];var aTmp='';var wTmp='';var dist=[];var alength=[];var acro='';var acroDef='';var fullAcro=false;var twoWordMin=false;var noCherryPicking=true;var noSkippedWords=true;var caseMatch=false;var acroCase=false;var twoChars=false;var notShortWord=false;var notSymbol=false;var startSentence=false;ng from startPos to the end of the sentence we're in;var txt=text.slice(startPos);var tmp=txt.match(/(?:[\\.\\?\\!])(?:(?: [A-Z])|(?: $)|(?:$))/);if (tmp) {txt=txt.slice(0,tmp.index);};nating everything except alpha-numeric and whitespace;tmp=JSON.parse(filterTheText('Aa0 ',txt));txt=tmp[0];nvert text to an array of characters.;txt=txt.split('');var txtPos=tmp[1];nother array of same length as txt that assigns a word id to each letter. Any non-alphanumeric characters;n the word ID of the character that is to the left of them.;var wordIds=[];wordIds.push(0);for (i=1;i < txt.length;i++) {;if (txt[i-1].match(/ /) && txt[i].match(/[^ ]/)) {;wordIds.push(wordIds[i-1]+1);new word;} else {;wordIds.push(wordIds[i-1]);} n same word id as prev. character;};nstruct an array similar to wordIds, but one that records the position where the word started rather than;nce of incrementing id values;var wordStarts=[];wordStarts.push(0);for (i=1;i < txt.length;i++) {;if (txt[i-1].match(/ /) && txt[i].match(/[^ ]/)) {;wordStarts.push(i);new word;} else {;wordStarts.push(wordStarts[i-1]);} n same value as prev. character;};for (i=0;i < txt.length-1;i++) {;if (txt[i].match(/[A-Za-z0-9]/)) {;tmp=txt.slice(i+1).reduce(function(x1,x2,x3) {;n the text with this ith character. At this point, the match is case-insensitive;if (x2.match(/[A-Za-z0-9]/) && wordStarts[x3+i+1] > wordStarts[i] &&;x2.toLowerCase() == txt.slice(i,i+1)[0].toLowerCase()) {x1.push(x3+i+1);} return x1;},[]);if (tmp.length > 0) {;linkedTo.push(tmp);from.push(i);};};};if (linkedTo.length == 0) {return '';};\"paths\" by which an acronym's letters could be matched up with;ng word definitions:;for (i=0;i < linkedTo[0].length;i++) {;if (wordStarts[linkedTo[0][i]] == linkedTo[0][i]) {;acroPos1.push([linkedTo[0][i]]);wordsPos1.push([from[0]]);};};for (i=1;i < linkedTo.length;i++) {n the test, from left to right;aPos=[];wPos=[];for (j=0;j < linkedTo[i].length;j++) {;for (k=0;k < acroPos1.length;k++) {;need to make combinations for each of these with all the acroPos that has been rolled up;nt. In order to be included, the jth value in the ith linkedTo needs to meet;ng criteria:;nym must be all be associated with the same \"word\" AND occur sequentially.;nition words must have their first letter involved in the acronym (which may be upper or lowercase).;n the middle of a word, those letters must also appear the acronym;n the first letter and uppercase letters within definition words are allowed so long as the;n the word are also present in the acronym.;aTmp=acroPos1[k];aTmp=aTmp[aTmp.length-1];wTmp=wordsPos1[k];wTmp=wTmp[wTmp.length-1];if ((wordStarts[linkedTo[i][j]] == wordStarts[aTmp] &&nym within single word;linkedTo[i][j] ==;aTmp + 1 && ntial acronym letters;wordStarts[from[i]] < wordStarts[aTmp] && nt location from acronym;from[i] > wTmp) && n def must be right of prev char;((wordStarts[from[i]] == from[i]) || ;(txt.slice(from[i],from[i]+1)[0].match(/[A-Z0-9]/) && number that ...;wordStarts[from[i]] == wordStarts[wTmp]) || nted word ... or...;(from[i] == wTmp + 1))) {nce w/ one of the above 2 cases;aPos.push(acroPos1[k].concat([linkedTo[i][j]]));wPos.push(wordsPos1[k].concat([from[i]]));};};};if (aPos.length > 0) {;acroPos1=acroPos1.concat(aPos);wordsPos1=wordsPos1.concat(wPos);};};acroPos2=[];wordsPos2=[];for (i=0;i < linkedTo[0].length;i++) {;if (wordStarts[linkedTo[0][i]] == linkedTo[0][i]) {;wordsPos2.push([linkedTo[0][i]]);acroPos2.push([from[0]]);};};for (i=1;i < linkedTo.length;i++) { n the test, from left to right;aPos=[];wPos=[];for (j=0;j < linkedTo[i].length;j++) {;for (k=0;k < acroPos2.length;k++) {;aTmp=acroPos2[k];aTmp=aTmp[aTmp.length-1];wTmp=wordsPos2[k];wTmp=wTmp[wTmp.length-1];if ((wordStarts[from[i]] == wordStarts[aTmp] && nym is one word;from[i] == aTmp + 1 && ntial acronym letters;wordStarts[linkedTo[i][j]] > wordStarts[aTmp] && nt location from acronym;linkedTo[i][j] > wTmp) && next char in def to right of last one;((wordStarts[linkedTo[i][j]] == linkedTo[i][j]) || ;(txt.slice(linkedTo[i][j],linkedTo[i][j]+1)[0].match(/[A-Z0-9]/) && number that ...;wordStarts[linkedTo[i][j]] == wordStarts[wTmp]) || nted word ... or ...;(linkedTo[i][j] == wTmp + 1))) {nce w/ one of the above 2 cases;aPos.push(acroPos2[k].concat([from[i]]));wPos.push(wordsPos2[k].concat([linkedTo[i][j]]));};};};if (aPos.length > 0) {;acroPos2=acroPos2.concat(aPos);wordsPos2=wordsPos2.concat(wPos);};};ne the findings from both kinds of searches;acroPos=acroPos1.concat(acroPos2);wordsPos=wordsPos1.concat(wordsPos2);n immediately weed out any 1-element entries:;acroPos=acroPos.filter(z => z.length > 1);wordsPos=wordsPos.filter(z => z.length > 1);ny found matches to insure compliance with other constraints:;n the group of chars associated with the acronym must have a counterpart in the def words;n] there must be at least 2 definition words;noCherryPicking] there cannot be any words larger than 3 letters laying between def words;noSkippedWords] there cannot be more than 3 words of length greater than 3 characters between the end of the;nition words and the beginning of the acro;nym has a mixture of lower/upper case characters, then there must be an exact case match;nding letters in the definition words. Likewise, if the definition words has a mixture of;n the acronym must provide an exact character-to-character case match, with the following exception:;nly uppercase letter in the definition words is the very first letter (e.g., likely the beginning of;ntence), and the acronym does NOT have a case-mixture, then a case-match is irrelevant. If the acronym;nt so long as the definition words do;not have a case-mixture (disregarding the case of the first letter in the def. words).;nym has any uppercase letters, there must be more uppercase than lowercase. If the;nym has only 2 characters, both must be uppercase if one of them is.;nym is only 2 letters, special precautions must be taken to insure that it is not just an ordinary;\"to\" or \"so\" or \"at\"). The 2-letter acronym must either consist of all consonants or;nstraint could likely remove viable acronyms from the index, but the risk of;ng such rules.;notShortWord] acronym can't be among the hardwired list of common \"small words\" (like \"etc\");notSymbol] acronym can't be mistaken for a chemical symbol (like \"Ne\" or \"He\");for (i=0;i < acroPos.length;i++) {;wTmp=wordsPos[i].map(z => txt.slice(z,z+1)[0]).join('');aTmp=acroPos[i].map(z => txt.slice(z,z+1)[0]).join('');fullAcro=false;twoWordMin=false;noCherryPicking=true;caseMatch=false;acroCase=false;twoChars=false;notShortWord=false;notSymbol=false;noSkippedWords=true;startSentence=false;ngth of the character grouping associated with the acronym itself by finding in the word ID all matches;nym characters have:;tmp=wordIds.reduce(function(x1,x2,x3) {;if (x2 == wordIds[acroPos[i][0]] && txt.slice(x3,x3+1)[0].match(/[A-Za-z0-9]/)) {x1.push(x2);} return x1;},[]);if (tmp.length == acroPos[i].length) {fullAcro=true;};n uppercase letter exists in the original text just before or just after the identified acro. If so, and it was skipped;n fullAcro gets turned back to false:;if (startPos > 0 && text.charAt(txtPos[acroPos[i]]).match(/[A-Z]/)) {fullAcro=false;};if (startPos < text.length-1 && text.charAt(txtPos[Math.max(... acroPos[i])]).match(/[A-Z]/)) {fullAcro=false;};nition words:;tmp=wordsPos[i].map(z => wordIds[z]);if (tmp !== undefined && tmp && tmp.length > 0 && ([... new Set(tmp)]).sort().length >= 2) {twoWordMin=true;};nition word IDs are not consequetive, determine how long the words are that are missing from this list;tst=[];if (twoWordMin) {;for (j=Math.min(... tmp)+1;j < Math.max(... tmp);j++) {;if (tmp.indexOf(j) == -1) {tst.push(j);};};};for (j=0;j < tst.length;j++) {;tmp=wordIds.reduce(function(x1,x2,x3) {;if (x2 == j && txt.slice(x3,x3+1)[0].match(/[A-Za-z0-9]/)) {x1.push(x2);} return x1;},[]);if (tmp.length <= 3) {noCherryPicking=false;};};ne the range of characters between the end of the definition words and the acronym:;tmp=acroPos[i].length;a1=acroPos[i][tmp-1];w1=wordsPos[i][0];a2=acroPos[i][0];tmp=wordsPos[i].length;w2=wordsPos[i][tmp-1];tmp='';if (wordIds[a1] < (wordIds[w1]-1)) {;tmp=txt.reduce(function(x1,x2,x3) {;if (wordIds[x3] > wordIds[a1] && wordIds[x3] < wordIds[w1]) {x1.push(x2);} return x1;},[]);tmp=tmp.join('').replace(/[^A-Za-z0-9 ]/g,'').replace(/ +/g,' ').trim();} else if (wordIds[w2] < (wordIds[a2]-1)) {;tmp=txt.reduce(function(x1,x2,x3) {;if (wordIds[x3] > wordIds[w2] && wordIds[x3] < wordIds[a2]) {x1.push(x2);} return x1;},[]);tmp=tmp.join('').replace(/[^A-Za-z0-9 ]/g,'').replace(/ +/g,' ').trim();};ny of the in-between words had uppercase letters, then the test is failed:;if (tmp.match(/[A-Z]/)) {noSkippedWords=false;};tmp =tmp.split(' ');tmp=tmp.filter(z => z.length > 3);n't count words of 3 characters or less;if (tmp.length > 3) {noSkippedWords=false;}n 3 substantial words lay between acro and def, fail the test;need to determine if the definition words start at the beginning of sentence.;if (startPos == 0) {;startSentence=true;} else if (text.slice(0,startPos).trim() == '') {;startSentence=true;} else if (startPos >= 2 && text.slice(startPos-2,startPos).trim() == '\\.') {;startSentence=true;};if (aTmp == wTmp) {caseMatch=true;};if (aTmp.match(/^[A-Z0-9]+$/) && wTmp.match(/^[a-z0-9]+$/)) {caseMatch=true;};nition words is a mix of cases that involves more than a capitalization of the start of a sentence,;nition word characters case-match with the acronym characters?;if (startSentence && aTmp.slice(1) == wTmp.slice(1)) {caseMatch=true;};nym characters, make sure there is consistency;if (aTmp.match(/^[A-Z0-9]+$/) || aTmp.match(/^[a-z0-9]+$/)) {acroCase=true;};if (aTmp.match(/[A-Z]/) && aTmp.match(/[a-z]/) && aTmp.match(/[A-Z]/g).length > aTmp.match(/[a-z]/g).length) {;acroCase=true;};nym length:;if (aTmp.length > 2) {twoChars=true;};if (!twoChars) {;nym consists of all consonants or of all vowels, then it passes the twoChar test:;tmp=acroPos[i].reduce(function(x1,x2,x3) {;if (txt.slice(x3,x3+1)[0].match(/[aeiou]/i)) {x1.push('v')} else {x1.push('c')};return x1;},[]);if (tmp.length > 0 && ([... new Set(tmp)]).length == 1) {twoChars=true;};};nym does not match any of the common short words:;if (smallWords.indexOf(aTmp) == -1) {notShortWord=true;};nym is not actually a chemical symbol!;tmp=xLtr.findIndex(z => z.reg !== undefined && z.symbol !== undefined && z.indx(aTmp,0) != '');if (tmp == -1) {notSymbol=true;};nd see if this acronym candidate failed ANY of the tests:;if (!(fullAcro*twoWordMin*noCherryPicking*noSkippedWords*caseMatch*acroCase*twoChars*notShortWord*notSymbol)) {;acroPos[i]=[-1];wordsPos[i]=[-1];};};ny -1 values:;acroPos=acroPos.filter(z => z[0] != -1);wordsPos=wordsPos.filter(z => z[0] != -1);now, there are more than 1 possibility for acronym and corresponding definition, then select whichever has the longest acronym.;nym length is the same for all the matches, then select the one for which the words and the acronym are closest together.;dist=[];alength=[];for (i=0;i < acroPos.length;i++) {;tmp=acroPos[i].map(z => txt.slice(z,z+1)[0]).join('');alength.push(tmp.length);if (acroPos[i][0] > wordsPos[i][0]) {;tmp=wordsPos[i].length;dist.push(txt.slice(wordsPos[i][tmp-1]+1,acroPos[i][0]+1).join('').replace(/[^A-Za-z0-9 ]/g,'').length);} else {;tmp=acroPos[i].length;dist.push(txt.slice(acroPos[i][tmp-1]+1,wordsPos[i][0]+1).join('').replace(/[^A-Za-z0-9 ]/g,'').length);};};for (i=0;i < acroPos.length;i++) {;if (alength[i] < Math.max(... alength)) {;acroPos[i]=[-1];wordsPos[i]=[-1];alength[i]=-1;dist[i]=-1;};};acroPos=acroPos.filter(z => z[0] != -1);wordsPos=wordsPos.filter(z => z[0] != -1);dist=dist.filter(z => z != -1);alength=alength.filter(z => z != -1);tmp=dist.findIndex(z => z == Math.min(... dist));ns the first one to meet criteria;acro='';acroDef='';if (tmp != -1) {;acroPos=acroPos[tmp];wordsPos=wordsPos[tmp];acro=acroPos.map(z => txt.slice(z,z+1)[0]).join('');tmp=[... new Set(wordsPos.map(z => wordStarts[z]))];tmp=[Math.min(... tmp), Math.max(... tmp)];tmp[1]=tmp[1] + wordStarts.filter(z => z == tmp[1]).length;acroDef=txt.slice(tmp[0],tmp[1]).join('').replace(/[^A-Za-z0-9]/g,' ').trim();this.startDef='' + (txtPos[tmp[0]] + startPos);this.endDef='' + (txtPos[tmp[1]-1] + 1 + startPos);acroDef=acroDef.replace(/ +/,' ').trim();if (acroPos[0] > wordsPos[0]) {;this.endMatch=\"\" + (txtPos[Math.max(... acroPos)] + 1 + startPos);} else {;this.endMatch=this.endDef;};return acro + ' ' + acroDef.replace(/ /g,'\\_');} else {return '';};}"},{"type":"citation","priority":"1","indx":"function(text, startPos) {;this.endMatch=\"-1\";this.authors=\"\";this.pubYear=\"\";this.journal=\"\";this.page=\"\";this.volume=\"\";var authors=[];var pubYear='';var journal='';var page='';var volume='';var journalAbb='';var tmp='';var t='';var m='';var t1='';var t2='';var shortCit='';ng from startPos;text=text.slice(startPos, startPos + 5000);nceforth, need to preserve character positions because at the end, need to know the actual position;nd of the match to to a bibliographic reference, so that the text can be masked out, etc by the;nction calling this procedure.;ns in identifying the bibliography, remove any Jr, Sr, I, II, etc from;text=text.replace(/([\\, ]+)(jr\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});text=text.replace(/([\\, ]+)(sr\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});text=text.replace(/([\\, ]+)(i+\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\"et al\" in the same way:;text=text.replace(/([\\, ]+)(et\\.? *al\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\"and\" in the same way ... if there is not a comma, force one to be there;text=text.replace(/[\\, ]+and[\\, ]+/ig, function(x){return '\\,' + x.slice(1).replace(/[ -~]/g,' ');});\"&\" in the same way:;text=text.replace(/[\\, ]+\\&[\\, ]+/ig, function(x){return '\\,' + x.slice(1).replace(/[ -~]/g,' ');});nces of hypenated names is a problem, like Smith-Jones. replace such occurances to be \"Smithjones\".;text=text.replace(/([A-Z][a-z]+)( *\\- *)([A-Z][a-z]+)/g, function(x,x1,x2,x3) {;return x1.charAt(0).toUpperCase() + x1.slice(1).toLowerCase() + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');});nces of names like O'Smith are a problem. Replace such occurances to be \"Osmith\";text=text.replace(/([A-Za-z]+)( *\\' *)([A-Za-z]+)/g, function(x,x1,x2,x3) {;return x1.charAt(0).toUpperCase() + x1.slice(1).toLowerCase() + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');});ndered as O Smith, try to catch and fix that situation as well by turning O Smith into \"Osmith\";text=text.replace(/([A-Z])( *)([A-Z][a-z]+)/g, function(x,x1,x2,x3) {;return x1 + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');});ng a set of characters that start with a capital letter,;nto the other characters, so that \"van Smith\" becomes \"Vansmith\";text=text.replace(/([\\, ]+)([a-z]{2,5})( *)([A-Z][a-z]+)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5) {;return x1 + x2.charAt(0).toUpperCase() + x2.slice(1) + x4.toLowerCase() + x5 + x3;});\"van Smith\" was rendered as VanSmith, or that O'Smith rendered as OSmith. There can;nly be 1 captial letter per last name, or the below algorithm fails. Need to fix this kind of situation so that VanSmith;ns into Vansmith and OSmith into Osmith. To fully cover all bases, find every word that starts with a lower case letter;n uppercase letter somewhere later in the word, and force all characters to be lowercase except for the first;text=text.replace(/([\\, ]+)([a-z]+)([A-Z])([A-Za-z]+)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5) {;return x1 + x2.charAt(0).toUpperCase() + x2.slice(1) + x3.toLowerCase() + x4.toLowerCase() + x5;});nd now get any word starting with an uppercase letter but has other uppercase letters somewhere else in the word, turn;nto all lower case except for first letter (note that we are about to really mess up any legitimate acronyms, but;nges are not permanent to the text;text=text.replace(/([\\, ]+)([A-Z]+)([a-z]+)([A-Z])([A-Za-z]*)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5,x6) {;return x1 + x2.charAt(0) + x2.slice(1).toLowerCase() + x3 + x4.toLowerCase() + x5.toLowerCase() + x6;});ny capital letters that stand in isolation -- those are likely to be initials. Note that initials are;ntified as being uppercase letters followed by a period (with possible white space bracketing the period).;text=text.replace(/([\\, ]+)((?:[A-Z] *\\. *){1,5})(\\,? *[12]{0,1})/g, function(x,x1,x2,x3) {;tmp='\\,' + (x1+x2).slice(1).replace(/[ -~]/g,' ');return tmp + x3.replace(/[^0-9]/g,' ');});nces within the text:;nalName,000,00 where 000,00 is the volume and page numbers, respectively;tmp=/^((?:(?:[A-Z][a-z]+\\,){1,20}(?:[A-Z][a-z]+)?)|(?:[A-Z][a-z]+))/.source +;/(?:([12]\\d\\d\\d[abc]{0,1})\\,([A-Z][A-Za-z]{1,100})\\,?(\\d+)\\,(\\d+))/.source;tmp=new RegExp(tmp);now filter the text big-time, removing everything except letters, numbers and commas;t=JSON.parse(filterTheText(/\\,/.source, text));m=t[0].match(tmp);authors=[];pubYear='';journal='';volume='';page='';if (m) {;nal reference is Smith, A. S., Jones, T. E., and Miller, W. D 2002, Astron. J., 145, 1;nes,Miller,2002,AstronJ,145,1 (note that the \"and\" and the initials would have already been;n a previous step above this \"while\" loop). Therefore, tmp will be (Smith,Jones,Miller)(2002)(AstronJ)(145)(1);n year:;pubYear=m[2].trim().replace(/[^0-9]/g,\"\");number:;volume=m[4].replace(/^0+/,\"\");ny preceding zeros;numner, but remove any page ranges. Any dashes would have already been filtered out;nd the page number will be the page range smushed together to look like a single number. go back;nfiltered text to make sure there is no dash in there:;t1=t[1][m[1].length + m[2].length + m[3].length + m[4].length - 1] + 1;t2=t[1][m[1].length + m[2].length + m[3].length + m[4].length + m[5].length - 1] + 1;page=text.slice(t1,t2).match(/[0-9]+/)[0].replace(/^0+/,\"\");nal name and convert into the journal abbreviation, but extract from the unfiltered text:;t1=t[1][m[1].length + m[2].length - 1] + 1;t2=t[1][m[1].length + m[2].length + m[3].length -1] + 1;journal=text.slice(t1,t2).trim();ne what the full name is for this journal by consulting the xLtr's \"journal\" entries:;tmp=xLtr.reduce(function(x1,x2,x3) {;if (x2.type == \"journal\" && x2.abb !== undefined && x2.indx(journal,0) != \"\" && parseFloat(x2.endMatch) > x1[1]) {;x1=[x3,parseFloat(x2.endMatch),x2.indx];} return x1;}, [-1,-1,'']);if (tmp[0] != -1 && tmp[1] == journal.length) {;journal=tmp[2];ndividual words delimited by _;} else {;nal name could not be found. Would be pointless to pass along the journal title;ndexing if some of the words are abbreviations like \"jrnl\" instead of \"journal\". as a;ny words that might be abbreviations and keep the rest of the words, delimiting;journal=journal.split(\" \").toLowerCase().map(z => z.trim());journal=journal.filter(z => !z.match(/\\./)).join(\"\\_\");};ndividual authors' last names:;authors=m[1].replace(/\\,/g,' ').replace(/ +/g,' ').trim().split(' ');names and publication year, put together the citation likely to appear in the text;shortCit='';n phrase... what this bibliography reference will likely look like in the text. For example, if the bibliography;ntry is Smith, A.K., Jones, Q. R., and Miller, D. R. 2010, ApJ, 545, 34, then the citation phrase might look like Smith et al 2010 or;nes & Miller 2010. Use both formats just to be certain.;if (authors.length > 3) {;shortCit=authors[0] + 'etal' + pubYear;} else if (authors.length == 3) {;shortCit=authors[0]+'etal'+pubYear+ '\\|' +;authors[0]+authors[1]+'and'+authors[2]+pubYear + '\\|' +;authors[0] + authors[1] + authors[2] + pubYear;;} else if (authors.length == 2) {;shortCit=authors[0] + 'and' + authors[1] + pubYear + '\\|' +;authors[0] + authors[1] + pubYear;;} else if (authors.length == 1) {;shortCit=authors[0] + pubYear;};pubYear=pubYear.replace(/[a-zA-Z]/g,'');this.endMatch='' + (t[1][m[0].length-1] + 1 + startPos);this.authors=([... new Set(authors)]).sort().join('\\_');this.pubYear=\"\"+pubYear;this.journal=journal;this.volume=volume;this.page=page;return shortCit.toLowerCase();} else {;return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"21","type":"ra","priority":"1","x":"","xSupp":"","nVals":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));if (m) {;this.endMatch=\"\"+(startPos + m[0].length);var tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[2];return tmp[0];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"21","type":"dec","priority":"1","x":"","xSupp":"","nVals":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));if (m) {;this.endMatch=\"\"+(startPos + m[0].length);var tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[3];return tmp[1];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])) *(?:(?:hours)|(?:hour)|(?:hrs)|(?:hr)|(?:h)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?( *[\\+\\-]{0,1}) *((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))) *(?:(?:textdegree)|(?:circ)|(?:degrees)|(?:degree)|(?:degs)|(?:deg)|(?:d)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?","nChars":"34","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var tmp=\"\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));if (m) {;this.endMatch=\"\"+(startPos + m[0].length);tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[2];return tmp[0];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])) *(?:(?:hours)|(?:hour)|(?:hrs)|(?:hr)|(?:h)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?( *[\\+\\-]{0,1}) *((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))) *(?:(?:textdegree)|(?:circ)|(?:degrees)|(?:degree)|(?:degs)|(?:deg)|(?:d)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?","nChars":"34","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));var tmp=\"\";if (m) {;this.endMatch=\"\"+(startPos + m[0].length);tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[3];return tmp[1];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:[0-8][0-9])|(?:[0-9](?![0-9])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"18","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));var tmp=\"\";if (m) {;this.endMatch=\"\"+(startPos + m[0].length);tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[2];return tmp[0];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:[0-8][0-9])|(?:[0-9](?![0-9])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"18","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var tmp=\"\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));if (m) {;this.endMatch=\"\"+(startPos + m[0].length);tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[3];return tmp[1];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:2[0-3])))([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?([\\+\\-])([0-8][0-9])([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?","nChars":"18","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var tmp=\"\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));if (m) {;this.endMatch=\"\"+(startPos + m[0].length);tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[2];return tmp[0];} else {return '';};}"},{"reg":"(^(?:(?:[0-1][0-9])|(?:2[0-3])))([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?([\\+\\-])([0-8][0-9])([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?","nChars":"18","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {;this.endMatch=\"-1\";var tmp=\"\";var m=text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));if (m) {;this.endMatch=\"\"+(startPos + m[0].length);tmp=extractRaDecVals(this.reg, text.slice(startPos));this.accuracy=tmp[3];return tmp[1];} else {return '';};}"},{"reg":"acoefficient","nChars":"12","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"acoefficients","nChars":"13","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"acoeff","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"acoeffs","nChars":"7","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient","x":"*b_*einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"einsteincoeff","nChars":"13","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient|*b_*einstein_coefficient","x":"*b_*einstein_coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"einsteincoeffs","nChars":"14","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient|*b_*einstein_coefficient","x":"*b_*einstein_coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"einsteincoefficients","nChars":"20","priority":"1","type":"jargon","tIndx":"*a_*einstein_coefficient|*b_*einstein_coefficient","x":"*b_*einstein_coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"ADC","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_to_digital_converter","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"astar","nChars":"5","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"astars","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"atypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"atypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"atype","nChars":"5","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"atypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"fnu","nChars":"3","priority":"1","type":"jargon","tIndx":"*ab_flux","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"mnu","nChars":"3","priority":"1","type":"jargon","tIndx":"*ab_magnitude","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metal","nChars":"5","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metals","nChars":"6","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metallicity","nChars":"11","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metalicity","nChars":"10","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metalicities","nChars":"12","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metallicities","nChars":"13","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metalicitys","nChars":"11","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"metallicitys","nChars":"12","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"agn","nChars":"3","priority":"1","type":"jargon","tIndx":"active_*galaxy_nucleus","x":"quasar","xSupp":"active_*galaxy_nucleus<X4>quasar","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"agns","nChars":"4","priority":"1","type":"jargon","tIndx":"active_*galaxy_nucleus","x":"quasar","xSupp":"active_*galaxy_nucleus<X4>quasar","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"ao","nChars":"2","priority":"1","type":"jargon","tIndx":"adaptive_optics","x":"","xSupp":"adaptive_optics<X4>seeing|diffraction_limited|tip_tilt","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"alp","nChars":"3","priority":"1","type":"jargon","tIndx":"*alpha","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"adu","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"adus","nChars":"4","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"dn","nChars":"2","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"dns","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"datanumber","nChars":"10","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"datanumbers","nChars":"11","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"aips","nChars":"4","priority":"1","type":"jargon","tIndx":"astronomical_image_processing_system","x":"","xSupp":"astronomical_image_processing_system<X4>radio|data_reduction_processing","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"aor","nChars":"3","priority":"1","type":"jargon","tIndx":"astronomical_observation_request","x":"","xSupp":"","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"agb","nChars":"3","priority":"1","type":"jargon","tIndx":"asymptotic_giant_branch_*star","x":"red_giant|mira_variable|*ohir_*star","xSupp":"asymptotic_giant_branch_*star<X4>circumstellar_envelope|maser_emission|thermal_pulse","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"agbs","nChars":"4","priority":"1","type":"jargon","tIndx":"asymptotic_giant_branch_*star","x":"red_giant|mira_variable|*ohir_*star","xSupp":"asymptotic_giant_branch_*star<X4>circumstellar_envelope|maser_emission|thermal_pulse","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"bcoefficient","nChars":"12","priority":"1","type":"jargon","tIndx":"*b_*einstein_coefficient","x":"*a_*einstein_coefficient","xSupp":"*b_*einstein_coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"},{"reg":"bcoefficients","nChars":"13","priority":"1","type":"jargon","tIndx":"*b_*einstein_coefficient","x":"*a_*einstein_coefficient","xSupp":"*b_*einstein_coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos) {;this.endMatch=\"-1\";var m;var t=JSON.parse(filterTheText(this.reg, text.slice(startPos)));ntains capitalized letters, then any match must also have those;n have the first;nning of a sentence, otherwise no match.;if (this.reg.match(/[A-Z]/)) {;m=t[0].match(new RegExp('^(?:'+this.reg+')'));} else {;m=t[0].match(new RegExp('^(?:'+this.reg+')'),'i');};var endMatch=-1;var rightTst=false;var leftTst=false;var middleTst=true;var capTst=true;if (m) {;endMatch=t[1][m[0].length-1] + 1 + startPos;ne more letter had been considered in the text, one would have retrieved the;ndexed, then allow that one additional word to be included in the match. For example,;ng is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would;nt to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":;if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch=endMatch + 1;};leftTst=true;rightTst=true;not a false-positive: if the word is less than 5 characters long,;nsure that there is a non-alphanumeric character on the right and left side of it in;nfiltered version of the text.;ngth <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {;;;ngth > 5) {leftTst=true;};ngth <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {;;ngth < endMatch+1) {rightTst=true;};ngth > 5) {rightTst=true;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst=false;};if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst=false;};n the first and last matched character to see if there is evidence;ntence breaks and other characters that should not appear in the middle of real words:;if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\;+[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst=false;};if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst=false;};};n't test for curly brackets, as they may be present as part of latex markup;n we've got a legit match:;if (!(leftTst*rightTst*middleTst*capTst)) {return \"\";};this.endMatch=\"\"+endMatch;return this.tIndx;}"}]