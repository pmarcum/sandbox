[{"type":"acro","priority":"1","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         this.startDef = \"-1\";\n         this.endDef = \"-1\";\n         var smallWords =\n           ['aka','al','am','an','and','are','as','at','be','by','do','eg','et','etal','etc',\n            'go','he','ie','if','in','io','is','it','me','my','no','ok','on','or','ox','pi',\n            'qi','so','to','we','xi'];\n         var linkedTo = [];\n         var from = [];\n         var i = 0;\n         var j = 0;\n         var k = 0;\n         var a1 = 0;\n         var a2 = 0;\n         var w1 = 0;\n         var w2 = 0;\n         var tst = '';\n         var t = '';\n         var endMatch = -1;\n         var acroPos1 = [];\n         var wordsPos1 = [];\n         var acroPos2 = [];\n         var wordsPos2 = [];\n         var acroPos = [];\n         var wordsPos = [];\n         var aPos = [];\n         var wPos = [];\n         var aTmp = '';\n         var wTmp = '';\n         var dist = [];\n         var alength = [];\n         var acro = '';\n         var acroDef = '';\n         var fullAcro = false;\n         var twoWordMin = false;\n         var noCherryPicking = true;\n         var noSkippedWords = true;\n         var caseMatch = false;\n         var acroCase = false;\n         var twoChars = false;\n         var notShortWord = false;\n         var notSymbol = false;\n         var startSentence = false;\n// Strip out text starting from startPos to the end of the sentence we're in\n         var txt = text.slice(startPos);\n         var tmp = txt.match(/(?:[\\.\\?\\!])(?:(?: [A-Z])|(?: $)|(?:$))/);\n         if (tmp) {txt = txt.slice(0,tmp.index);}\n// filter the text, eliminating everything except alpha-numeric and whitespace\n         tmp = JSON.parse(filterTheText('Aa0 ',txt));\n         txt = tmp[0];\n// Convert text to an array of characters.\n         txt = txt.split('');\n         var txtPos = tmp[1];\n// make another array of same length as txt that assigns a word id to each letter. Any non-alphanumeric characters\n// take on the word ID of the character that is to the left of them.\n         var wordIds = [];\n         wordIds.push(0);\n         for (i = 1; i < txt.length; i++) {\n           if (txt[i-1].match(/ /) && txt[i].match(/[^ ]/)) {\n             wordIds.push(wordIds[i-1]+1); // start new word\n           } else {\n             wordIds.push(wordIds[i-1]);} // retain same word id as prev. character\n         }\n// construct an array similar to wordIds, but one that records the position where the word started rather than\n// a sequence of incrementing id values\n         var wordStarts = [];\n         wordStarts.push(0);\n         for (i = 1; i < txt.length; i++) {\n           if (txt[i-1].match(/ /) && txt[i].match(/[^ ]/)) {\n             wordStarts.push(i); // start new word\n           } else {\n             wordStarts.push(wordStarts[i-1]);} // retain same value as prev. character\n         }\n         for (i = 0; i < txt.length-1; i++) {\n           if (txt[i].match(/[A-Za-z0-9]/)) {\n// get all the text to the right of the ith character\n             tmp = txt.slice(i+1).reduce(function(x1,x2,x3) {\n// locate all the matches in the text with this ith character. At this point, the match is case-insensitive\n               if (x2.match(/[A-Za-z0-9]/) && wordStarts[x3+i+1] > wordStarts[i] &&\n               x2.toLowerCase() == txt.slice(i,i+1)[0].toLowerCase()) {x1.push(x3+i+1);} return x1;},[]);\n             if (tmp.length > 0) {\n               linkedTo.push(tmp);\n               from.push(i);}\n           }\n         }\n// - - - - - - - - - - - - - - - - - - - - - - - -\n         if (linkedTo.length == 0) {return '';}\n// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n// Now map out all the possible \"paths\" by which an acronym's letters could be matched up with\n// legitimate characters from preceeding word definitions:\n         for (i = 0; i < linkedTo[0].length; i++) {\n           if (wordStarts[linkedTo[0][i]] == linkedTo[0][i]) {\n             acroPos1.push([linkedTo[0][i]]);\n             wordsPos1.push([from[0]]);}\n         }\n         for (i = 1; i < linkedTo.length; i++) {// step through each character in the test, from left to right\n           aPos = [];\n           wPos = [];\n           for (j = 0; j < linkedTo[i].length; j++) {\n             for (k = 0; k < acroPos1.length; k++) {\n// need to make combinations for each of these with all the acroPos that has been rolled up\n// to this point. In order to be included, the jth value in the ith linkedTo needs to meet\n// the following criteria:\n// * characters associated with the acronym must be all be associated with the same \"word\"  AND occur sequentially.\n// * all definition words must have their first letter involved in the acronym (which may be upper or lowercase).\n// * if there are uppercase letters somewhere in the middle of a word, those letters must also appear the acronym\n//   as well as the first character of that word.\n// * letters other than the first letter and uppercase letters within definition words are allowed so long as the\n//   letter(s) to the left of them in the word are also present in the acronym.\n               aTmp = acroPos1[k];\n               aTmp = aTmp[aTmp.length-1];\n               wTmp = wordsPos1[k];\n               wTmp = wTmp[wTmp.length-1];\n               if ((wordStarts[linkedTo[i][j]] == wordStarts[aTmp] &&// acronym within single word\n                    linkedTo[i][j] ==\n                    aTmp + 1 && // sequential acronym letters\n                    wordStarts[from[i]] < wordStarts[aTmp] && // different location from acronym\n                    from[i] > wTmp) && // char in def must be right of prev char\n                    ((wordStarts[from[i]] == from[i]) || // first letter of a word ... or ...\n                     (txt.slice(from[i],from[i]+1)[0].match(/[A-Z0-9]/) && // is uppercase char or number that ...\n                      wordStarts[from[i]] == wordStarts[wTmp]) || // is part already-represented word ... or...\n                      (from[i] == wTmp + 1))) {// is part of sequence w/ one of the above 2 cases\n                   aPos.push(acroPos1[k].concat([linkedTo[i][j]]));\n                   wPos.push(wordsPos1[k].concat([from[i]]));}\n             }\n           }\n           if (aPos.length > 0) {\n             acroPos1 = acroPos1.concat(aPos);\n             wordsPos1 = wordsPos1.concat(wPos);}\n         }\n         acroPos2 = [];\n         wordsPos2 = [];\n         for (i = 0; i < linkedTo[0].length; i++) {\n           if (wordStarts[linkedTo[0][i]] == linkedTo[0][i]) {\n             wordsPos2.push([linkedTo[0][i]]);\n             acroPos2.push([from[0]]);}\n         }\n         for (i = 1; i < linkedTo.length; i++) { // step through each character in the test, from left to right\n           aPos = [];\n           wPos = [];\n           for (j = 0; j < linkedTo[i].length; j++) {\n             for (k = 0; k < acroPos2.length; k++) {\n               aTmp = acroPos2[k];\n               aTmp = aTmp[aTmp.length-1];\n               wTmp = wordsPos2[k];\n               wTmp = wTmp[wTmp.length-1];\n               if ((wordStarts[from[i]] == wordStarts[aTmp] && // acronym is one word\n                    from[i] == aTmp + 1 && // sequential acronym letters\n                    wordStarts[linkedTo[i][j]] > wordStarts[aTmp] && // different location from acronym\n                    linkedTo[i][j] > wTmp) && // the next char in def to right of last one\n                    ((wordStarts[linkedTo[i][j]] == linkedTo[i][j]) || // first letter of a word ... or ...\n                     (txt.slice(linkedTo[i][j],linkedTo[i][j]+1)[0].match(/[A-Z0-9]/) && // is uppercase char or number that ...\n                      wordStarts[linkedTo[i][j]] == wordStarts[wTmp]) || // is part of already-represented word ... or ...\n                     (linkedTo[i][j] == wTmp + 1))) {// is part of sequence w/ one of the above 2 cases\n                  aPos.push(acroPos2[k].concat([from[i]]));\n                  wPos.push(wordsPos2[k].concat([linkedTo[i][j]]));}\n             }\n           }\n           if (aPos.length > 0) {\n             acroPos2 = acroPos2.concat(aPos);\n             wordsPos2 = wordsPos2.concat(wPos);}\n         }\n// combine the findings from both kinds of searches\n         acroPos = acroPos1.concat(acroPos2);\n         wordsPos = wordsPos1.concat(wordsPos2);\n// We can immediately weed out any 1-element entries:\n         acroPos = acroPos.filter(z => z.length > 1);\n         wordsPos = wordsPos.filter(z => z.length > 1);\n// Now test any found matches to insure compliance with other constraints:\n//  * [fullAcro] each character within the group of chars associated with the acronym must have a counterpart in the def words\n//  * [twoWordMin] there must be at least 2 definition words\n//  * [noCherryPicking] there cannot be any words larger than 3 letters laying between def words\n//  * [noSkippedWords]  there cannot be more than 3 words of length greater than 3 characters between the end of the\n//    definition words and the beginning of the acro\n//  * [caseMatch] If the acronym has a mixture of lower/upper case characters, then there must be an exact case match\n//    to those corresponding letters in the definition words.  Likewise, if the definition words has a mixture of\n//    cases, then the acronym must provide an exact character-to-character case match, with the following exception:\n//    if the only uppercase letter in the definition words is the very first letter (e.g., likely the beginning of\n//    a sentence), and the acronym does NOT have a case-mixture, then a case-match is irrelevant. If the acronym\n//    has all caps or all lowercase characters, a case-match is irrelevant so long as the definition words do\n//    not have a case-mixture (disregarding the case of the first letter in the def. words).\n//  * [acroCase] If the acronym has any uppercase letters, there must be more uppercase than lowercase. If the\n//    acronym has only 2 characters, both must be uppercase if one of them is.\n//  * [twoChars] if the acronym is only 2 letters, special precautions must be taken to insure that it is not just an ordinary\n//    2-letter word (like \"to\" or \"so\" or \"at\"). The 2-letter acronym must either consist of all consonants or\n//    all vowels. Note that this constraint could likely remove viable acronyms from the index, but the risk of\n//    false-positive matches is just too high to accept without imposing such rules.\n//  * [notShortWord] acronym can't be among the hardwired list of common \"small words\" (like \"etc\")\n//  * [notSymbol] acronym can't be mistaken for a chemical symbol (like \"Ne\" or \"He\")\n         for (i = 0; i < acroPos.length; i++) {\n           wTmp = wordsPos[i].map(z => txt.slice(z,z+1)[0]).join('');\n           aTmp = acroPos[i].map(z => txt.slice(z,z+1)[0]).join('');\n           fullAcro = false;\n           twoWordMin = false;\n           noCherryPicking = true;\n           caseMatch = false;\n           acroCase = false;\n           twoChars = false;\n           notShortWord = false;\n           notSymbol = false;\n           noSkippedWords = true;\n           startSentence = false;\n// get the length of the character grouping associated with the acronym itself by finding in the word ID all matches\n// to the word ID value that the acronym characters have:\n           tmp = wordIds.reduce(function(x1,x2,x3) {\n             if (x2 == wordIds[acroPos[i][0]] && txt.slice(x3,x3+1)[0].match(/[A-Za-z0-9]/)) {x1.push(x2);} return x1;},[]);\n             if (tmp.length == acroPos[i].length) {fullAcro = true;}\n// See if an uppercase letter exists in the original text just before or just after the identified acro.  If so, and it was skipped\n// over, then fullAcro gets turned back to false:\n             if (startPos > 0 && text.charAt(txtPos[acroPos[i]]).match(/[A-Z]/)) {fullAcro = false;}\n             if (startPos < text.length-1 && text.charAt(txtPos[Math.max(... acroPos[i])]).match(/[A-Z]/)) {fullAcro = false;}\n// get a list of all the word IDs associated with the definition words:\n             tmp = wordsPos[i].map(z => wordIds[z]);\n             if (tmp !== undefined && tmp && tmp.length > 0 && ([... new Set(tmp)]).sort().length >= 2) {twoWordMin = true;}\n// If these definition word IDs are not consequetive, determine how long the words are that are missing from this list\n             tst = [];\n             if (twoWordMin) {\n               for (j = Math.min(... tmp)+1; j < Math.max(... tmp); j++) {\n                 if (tmp.indexOf(j) == -1) {tst.push(j);}\n               }\n             }\n             for (j = 0; j < tst.length; j++) {\n               tmp = wordIds.reduce(function(x1,x2,x3) {\n                 if (x2 == j && txt.slice(x3,x3+1)[0].match(/[A-Za-z0-9]/)) {x1.push(x2);} return x1;},[]);\n                 if (tmp.length <= 3) {noCherryPicking = false;}\n             }\n// determine the range of characters between the end of the definition words and the acronym:\n             tmp = acroPos[i].length;\n             a1 = acroPos[i][tmp-1];\n             w1 = wordsPos[i][0];\n             a2 = acroPos[i][0];\n             tmp = wordsPos[i].length;\n             w2 = wordsPos[i][tmp-1];\n             tmp = '';\n             if (wordIds[a1] < (wordIds[w1]-1)) {\n               tmp = txt.reduce(function(x1,x2,x3) {\n                 if (wordIds[x3] > wordIds[a1] && wordIds[x3] < wordIds[w1]) {x1.push(x2);} return x1;},[]);\n                 tmp = tmp.join('').replace(/[^A-Za-z0-9 ]/g,'').replace(/  +/g,' ').trim();\n             } else if (wordIds[w2] < (wordIds[a2]-1)) {\n               tmp = txt.reduce(function(x1,x2,x3) {\n                 if (wordIds[x3] > wordIds[w2] && wordIds[x3] < wordIds[a2]) {x1.push(x2);} return x1;},[]);\n                 tmp = tmp.join('').replace(/[^A-Za-z0-9 ]/g,'').replace(/  +/g,' ').trim();}\n// If any of the in-between words had uppercase letters, then the test is failed:\n             if (tmp.match(/[A-Z]/)) {noSkippedWords = false;}\n             tmp =tmp.split(' ');\n             tmp = tmp.filter(z => z.length > 3);// don't count words of 3 characters or less\n             if (tmp.length > 3) {noSkippedWords = false; }// if more than 3 substantial words lay between acro and def, fail the test\n// For the below tests, need to determine if the definition words start at the beginning of sentence.\n             if (startPos == 0) {\n               startSentence = true;\n             } else if (text.slice(0,startPos).trim() == '') {\n               startSentence = true;\n             } else if (startPos >= 2 && text.slice(startPos-2,startPos).trim() == '\\.') {\n               startSentence = true;}\n             if (aTmp == wTmp) {caseMatch = true;}\n             if (aTmp.match(/^[A-Z0-9]+$/) && wTmp.match(/^[a-z0-9]+$/)) {caseMatch = true;}\n// If the definition words is a mix of cases that involves more than a capitalization of the start of a sentence,\n// do definition word characters case-match with the acronym characters?\n             if (startSentence && aTmp.slice(1) == wTmp.slice(1)) {caseMatch = true;}\n// check the case of the acronym characters, make sure there is consistency\n             if (aTmp.match(/^[A-Z0-9]+$/) || aTmp.match(/^[a-z0-9]+$/)) {acroCase = true;}\n             if (aTmp.match(/[A-Z]/) && aTmp.match(/[a-z]/) && aTmp.match(/[A-Z]/g).length > aTmp.match(/[a-z]/g).length) {\n               acroCase = true;}\n// Now check the acronym length:\n             if (aTmp.length > 2) {twoChars = true;}\n             if (!twoChars) {\n// If the acronym consists of all consonants or of all vowels, then it passes the twoChar test:\n                tmp = acroPos[i].reduce(function(x1,x2,x3) {\n                  if (txt.slice(x3,x3+1)[0].match(/[aeiou]/i)) {x1.push('v')} else {x1.push('c')}; return x1;},[]);\n                  if (tmp.length > 0 && ([... new Set(tmp)]).length == 1) {twoChars = true;}\n             }\n// Make sure that acronym does not match any of the common short words:\n             if (smallWords.indexOf(aTmp) == -1) {notShortWord = true;}\n// Now check that the acronym is not actually a chemical symbol!\n             tmp = xLtr.findIndex(z => z.reg !== undefined && z.symbol !== undefined && z.indx(aTmp,0) != '');\n             if (tmp == -1) {notSymbol = true;}\n// Now tally up the scores and see if this acronym candidate failed ANY of the tests:\n             if (!(fullAcro*twoWordMin*noCherryPicking*noSkippedWords*caseMatch*acroCase*twoChars*notShortWord*notSymbol)) {\n               acroPos[i] = [-1];\n               wordsPos[i] = [-1];}\n         }\n// Remove any -1 values:\n         acroPos = acroPos.filter(z => z[0] != -1);\n         wordsPos = wordsPos.filter(z => z[0] != -1);\n// If by now, there are more than 1 possibility for acronym and corresponding definition, then select whichever has the longest acronym.\n// If the acronym length is the same for all the matches, then select the one for which the words and the acronym are closest together.\n         dist = [];\n         alength = [];\n         for (i = 0; i < acroPos.length; i++) {\n           tmp = acroPos[i].map(z => txt.slice(z,z+1)[0]).join('');\n           alength.push(tmp.length);\n           if (acroPos[i][0] > wordsPos[i][0]) {\n             tmp = wordsPos[i].length;\n             dist.push(txt.slice(wordsPos[i][tmp-1]+1,acroPos[i][0]+1).join('').replace(/[^A-Za-z0-9 ]/g,'').length);\n           } else {\n             tmp = acroPos[i].length;\n             dist.push(txt.slice(acroPos[i][tmp-1]+1,wordsPos[i][0]+1).join('').replace(/[^A-Za-z0-9 ]/g,'').length);}\n         }\n         for (i = 0; i < acroPos.length; i++) {\n           if (alength[i] < Math.max(... alength)) {\n             acroPos[i] = [-1];\n             wordsPos[i] = [-1];\n             alength[i] = -1;\n             dist[i] = -1;}\n         }\n         acroPos = acroPos.filter(z => z[0] != -1);\n         wordsPos = wordsPos.filter(z => z[0] != -1);\n         dist = dist.filter(z => z != -1);\n         alength = alength.filter(z => z != -1);\n         tmp = dist.findIndex(z => z == Math.min(... dist));// returns the first one to meet criteria\n         acro = '';\n         acroDef = '';\n         if (tmp != -1) {\n           acroPos = acroPos[tmp];\n           wordsPos = wordsPos[tmp];\n           acro = acroPos.map(z => txt.slice(z,z+1)[0]).join('');\n           tmp = [... new Set(wordsPos.map(z => wordStarts[z]))];\n           tmp = [Math.min(... tmp), Math.max(... tmp)];\n           tmp[1] = tmp[1] + wordStarts.filter(z => z == tmp[1]).length;\n           acroDef = txt.slice(tmp[0],tmp[1]).join('').replace(/[^A-Za-z0-9]/g,' ').trim();\n           this.startDef = '' + (txtPos[tmp[0]] + startPos);\n           this.endDef = '' + (txtPos[tmp[1]-1] + 1 + startPos);\n           acroDef = acroDef.replace(/  +/,' ').trim();\n           if (acroPos[0] > wordsPos[0]) {\n             this.endMatch = \"\" + (txtPos[Math.max(... acroPos)] + 1 + startPos);\n           } else {\n             this.endMatch = this.endDef;}\n           return acro + ' ' + acroDef.replace(/ /g,'\\_');\n         } else {return '';}\n      }"},{"type":"citation","priority":"1","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         this.authors = \"\";\n         this.pubYear = \"\";\n         this.journal = \"\";\n         this.page = \"\";\n         this.volume = \"\";\n         var authors = [];\n         var pubYear = '';\n         var journal = '';\n         var page = '';\n         var volume = '';\n         var journalAbb = '';\n         var tmp = '';\n         var t = '';\n         var m = '';\n         var t1 = '';\n         var t2 = '';\n         var shortCit = '';\n// Strip out text starting from startPos\n         text = text.slice(startPos, startPos + 5000);\n// From henceforth, need to preserve character positions because at the end, need to know the actual position\n// of the end of the match to to a bibliographic reference, so that the text can be masked out, etc by the\n// function calling this procedure.\n// to reduce complications in identifying the bibliography, remove any Jr, Sr, I, II, etc from\n         text = text.replace(/([\\, ]+)(jr\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n         text = text.replace(/([\\, ]+)(sr\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n         text = text.replace(/([\\, ]+)(i+\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n// replace \"et al\" in the same way:\n         text = text.replace(/([\\, ]+)(et\\.? *al\\.?)([\\, ]+)/ig, function(x,x1,x2,x3){return x3 + (x1+x2).replace(/[ -~]/g,' ');});\n// replace \"and\" in the same way ... if there is not a comma, force one to be there\n         text = text.replace(/[\\, ]+and[\\, ]+/ig, function(x){return '\\,' + x.slice(1).replace(/[ -~]/g,' ');});\n// replace \"&\" in the same way:\n         text = text.replace(/[\\, ]+\\&[\\, ]+/ig, function(x){return '\\,' + x.slice(1).replace(/[ -~]/g,' ');});\n// Occurances of hypenated names is a problem, like Smith-Jones.  replace such occurances to be \"Smithjones\".\n         text = text.replace(/([A-Z][a-z]+)( *\\- *)([A-Z][a-z]+)/g, function(x,x1,x2,x3) {\n           return x1.charAt(0).toUpperCase() + x1.slice(1).toLowerCase() + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');});\n// Occurances of names like O'Smith are a problem. Replace such occurances to be \"Osmith\"\n         text = text.replace(/([A-Za-z]+)( *\\' *)([A-Za-z]+)/g, function(x,x1,x2,x3) {\n           return x1.charAt(0).toUpperCase() + x1.slice(1).toLowerCase() + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');})\n// If O'Smith got rendered as O Smith, try to catch and fix that situation as well by turning O Smith into \"Osmith\"\n         text = text.replace(/([A-Z])( *)([A-Z][a-z]+)/g, function(x,x1,x2,x3) {\n           return x1 + x3.toLowerCase() + x2.replace(/[ -~]/g,' ');})\n// If there are characters that are all lowercase preceding a set of characters that start with a capital letter,\n// scoot the lowercase characters into the other characters, so that \"van Smith\" becomes \"Vansmith\"\n         text = text.replace(/([\\, ]+)([a-z]{2,5})( *)([A-Z][a-z]+)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5) {\n           return x1 + x2.charAt(0).toUpperCase() + x2.slice(1) + x4.toLowerCase() + x5 + x3; });\n// There could be the case that \"van Smith\" was rendered as VanSmith, or that O'Smith rendered as OSmith.  There can\n// only be 1 captial letter per last name, or the below algorithm fails. Need to fix this kind of situation so that VanSmith\n// turns into Vansmith and OSmith into Osmith. To fully cover all bases, find every word that starts with a lower case letter\n// but has an uppercase letter somewhere later in the word, and force all characters to be lowercase except for the first\n// letter, which is forced to be uppercase:\n         text = text.replace(/([\\, ]+)([a-z]+)([A-Z])([A-Za-z]+)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5) {\n           return x1 + x2.charAt(0).toUpperCase() + x2.slice(1) + x3.toLowerCase() + x4.toLowerCase() + x5; });\n// And now get any word starting with an uppercase letter but has other uppercase letters somewhere else in the word, turn\n// unto all lower case except for first letter (note that we are about to really mess up any legitimate acronyms, but\n// that's OK because these changes are not permanent to the text\n         text = text.replace(/([\\, ]+)([A-Z]+)([a-z]+)([A-Z])([A-Za-z]*)([\\, ]+)/g, function(x,x1,x2,x3,x4,x5,x6) {\n           return x1 + x2.charAt(0) + x2.slice(1).toLowerCase() + x3 + x4.toLowerCase() + x5.toLowerCase() + x6; });\n// Remove any capital letters that stand in isolation -- those are likely to be initials. Note that initials are\n// identified as being uppercase letters followed by a period (with possible white space bracketing the period).\n         text = text.replace(/([\\, ]+)((?:[A-Z] *\\. *){1,5})(\\,? *[12]{0,1})/g, function(x,x1,x2,x3) {\n           tmp = '\\,' + (x1+x2).slice(1).replace(/[ -~]/g,' ');\n           return tmp + x3.replace(/[^0-9]/g,' '); });\n// Create a regexp that looks for groups of characters that look like references within the text:\n// Name,Name,Name2022,JournalName,000,00 where 000,00 is the volume and page numbers, respectively\n         tmp = /^((?:(?:[A-Z][a-z]+\\,){1,20}(?:[A-Z][a-z]+)?)|(?:[A-Z][a-z]+))/.source +\n               /(?:([12]\\d\\d\\d[abc]{0,1})\\,([A-Z][A-Za-z]{1,100})\\,?(\\d+)\\,(\\d+))/.source;\n         tmp = new RegExp(tmp);\n// OK, now filter the text big-time, removing everything except letters, numbers and commas\n         t = JSON.parse(filterTheText(/\\,/.source, text));\n         m = t[0].match(tmp);\n         authors = [];\n         pubYear = '';\n         journal = '';\n         volume = '';\n         page = '';\n         if (m) {\n// if the original reference is Smith, A. S., Jones, T. E., and Miller, W. D 2002, Astron. J., 145, 1\n// the filtered view would be Smith,Jones,Miller,2002,AstronJ,145,1 (note that the \"and\" and the initials would have already been\n// removed in a previous step above this \"while\" loop). Therefore, tmp will be (Smith,Jones,Miller)(2002)(AstronJ)(145)(1)\n// extract the publication year:\n           pubYear = m[2].trim().replace(/[^0-9]/g,\"\");\n// extract the volume number:\n           volume = m[4].replace(/^0+/,\"\");//remove any preceding zeros\n// get the page numner, but remove any page ranges.  Any dashes would have already been filtered out\n// and the page number will be the page range smushed together to look like a single number.  go back\n// to unfiltered text to make sure there is no dash in there:\n           t1 = t[1][m[1].length + m[2].length + m[3].length + m[4].length - 1] + 1;\n           t2 = t[1][m[1].length + m[2].length + m[3].length + m[4].length + m[5].length - 1] + 1;\n           page = text.slice(t1,t2).match(/[0-9]+/)[0].replace(/^0+/,\"\");\n// extract the journal name and convert into the journal abbreviation, but extract from the unfiltered text:\n           t1 = t[1][m[1].length + m[2].length - 1] + 1;\n           t2 = t[1][m[1].length + m[2].length + m[3].length -1] + 1;\n           journal = text.slice(t1,t2).trim();\n// determine what the full name is for this journal by consulting the xLtr's \"journal\" entries:\n           tmp = xLtr.reduce(function(x1,x2,x3) {\n             if (x2.type == \"journal\" && x2.abb !== undefined && x2.indx(journal,0) != \"\" && parseFloat(x2.endMatch) > x1[1]) {\n             x1 = [x3,parseFloat(x2.endMatch),x2.indx];} return x1;}, [-1,-1,'']);\n           if (tmp[0] != -1 && tmp[1] == journal.length) {\n             journal = tmp[2];// individual words delimited by _\n           } else {\n// a match to the journal name could not be found. Would be pointless to pass along the journal title\n// words for indexing if some of the words are abbreviations like \"jrnl\" instead of \"journal\".  as a\n// compromise, remove any words that might be abbreviations and keep the rest of the words, delimiting\n// them with _\n             journal = journal.split(\" \").toLowerCase().map(z => z.trim());\n             journal = journal.filter(z => !z.match(/\\./)).join(\"\\_\");}\n// extract the individual authors' last names:\n           authors = m[1].replace(/\\,/g,' ').replace(/  +/g,' ').trim().split(' ');\n// Now that we have the author names and publication year, put together the citation likely to appear in the text\n           shortCit = '';\n// Now create a  citation phrase... what this bibliography reference will likely look like in the text. For example, if the bibliography\n// entry is Smith, A.K., Jones, Q. R., and Miller, D. R. 2010, ApJ, 545, 34, then the citation phrase might look like Smith et al 2010 or\n// maybe Smith, Jones & Miller 2010. Use both formats just to be certain.\n           if (authors.length > 3) {\n             shortCit = authors[0] + 'etal' + pubYear;\n           } else if (authors.length == 3) {\n             shortCit = authors[0]+'etal'+pubYear+ '\\|' +\n                        authors[0]+authors[1]+'and'+authors[2]+pubYear + '\\|' +\n                        authors[0] + authors[1] + authors[2] + pubYear; // 3 possibilities\n           } else if (authors.length == 2) {\n             shortCit = authors[0] + 'and' + authors[1] + pubYear + '\\|' +\n                        authors[0] + authors[1] + pubYear; // 2 possibilities\n           } else if (authors.length == 1) {\n             shortCit = authors[0] + pubYear;}\n           pubYear = pubYear.replace(/[a-zA-Z]/g,'');\n           this.endMatch = '' + (t[1][m[0].length-1] + 1 + startPos);\n           this.authors = ([... new Set(authors)]).sort().join('\\_');\n           this.pubYear = \"\"+pubYear;\n           this.journal = journal;\n           this.volume = volume;\n           this.page = page;\n           return shortCit.toLowerCase();\n         } else {\n           return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"21","type":"ra","priority":"1","x":"","xSupp":"","nVals":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           var tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( *\\: *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"21","type":"dec","priority":"1","x":"","xSupp":"","nVals":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           var tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])) *(?:(?:hours)|(?:hour)|(?:hrs)|(?:hr)|(?:h)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?( *[\\+\\-]{0,1}) *((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))) *(?:(?:textdegree)|(?:circ)|(?:degrees)|(?:degree)|(?:degs)|(?:deg)|(?:d)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?","nChars":"34","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var tmp = \"\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])) *(?:(?:hours)|(?:hour)|(?:hrs)|(?:hr)|(?:h)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?( *[\\+\\-]{0,1}) *((?:(?:[0-8][0-9])|(?:[0-9](?![0-9]))) *(?:(?:textdegree)|(?:circ)|(?:degrees)|(?:degree)|(?:degs)|(?:deg)|(?:d)))( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m))?)( *(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))) *(?:(?:seconds)|(?:second)|(?:sec)|(?:s))?)?( *(?:\\. *[0-9]+)? *(?:(?:minutes)|(?:minute)|(?:mins)|(?:min)|(?:m)|(?:seconds)|(?:second)|(?:sec)|(?:s)))?","nChars":"34","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         var tmp = \"\";\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:[0-8][0-9])|(?:[0-9](?![0-9])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"18","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         var tmp = \"\";\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:[0-9](?![0-9]))|(?:2[0-3])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?( +[\\+\\-]{0,1} *)((?:[0-8][0-9])|(?:[0-9](?![0-9])))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))( +(?:(?:[0-5][0-9])|(?:[0-9](?![0-9]))))?( *\\. *[0-9]+)?","nChars":"18","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var tmp = \"\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:2[0-3])))([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?([\\+\\-])([0-8][0-9])([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?","nChars":"18","type":"ra","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var tmp = \"\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[2];\n           return tmp[0];\n         } else {return '';}\n      }"},{"reg":"(^(?:(?:[0-1][0-9])|(?:2[0-3])))([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?([\\+\\-])([0-8][0-9])([0-5][0-9])([0-5][0-9])?(\\.[0-9]+)?","nChars":"18","type":"dec","priority":"1","x":"","xSupp":"","nVars":"2","indx":"function(text, startPos) {\n         this.endMatch = \"-1\";\n         var tmp = \"\";\n         var m = text.slice(startPos).match(new RegExp('^(?:' + this.reg + ')'));\n         if (m) {\n           this.endMatch = \"\"+(startPos + m[0].length);\n           tmp = extractRaDecVals(this.reg, text.slice(startPos));\n           this.accuracy = tmp[3];\n           return tmp[1];\n         } else {return '';}\n      }"},{"reg":"acoefficient","nChars":"12","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient","x":"*b_*einstein_*coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"acoefficients","nChars":"13","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient","x":"*b_*einstein_*coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"acoeff","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient","x":"*b_*einstein_*coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"acoeffs","nChars":"7","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient","x":"*b_*einstein_*coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"einsteincoeff","nChars":"13","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient|*b_*einstein_coefficient","x":"*b_*einstein_*coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"einsteincoeffs","nChars":"14","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient|*b_*einstein_coefficient","x":"*b_*einstein_*coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"einsteincoefficients","nChars":"20","priority":"1","type":"jargon","tIndx":"*a_*einstein_*coefficient|*b_*einstein_coefficient","x":"*b_*einstein_*coefficient|*a_einstein_coefficient","xSupp":"*a_*einstein_*coefficient<X4>*b_einstein_coefficent *b_*einstein_coefficient<X4>a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ADC","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_to_digital_converter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"astar","nChars":"5","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"astars","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atype","nChars":"5","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"atypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*a_*star","x":"","xSupp":"*a_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fnu","nChars":"3","priority":"1","type":"jargon","tIndx":"*ab_flux","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mnu","nChars":"3","priority":"1","type":"jargon","tIndx":"*ab_magnitude","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metal","nChars":"5","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metals","nChars":"6","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metallicity","nChars":"11","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metalicity","nChars":"10","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metalicities","nChars":"12","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metallicities","nChars":"13","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metalicitys","nChars":"11","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"metallicitys","nChars":"12","priority":"1","type":"jargon","tIndx":"abundance","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agn","nChars":"3","priority":"1","type":"jargon","tIndx":"active_*galaxy_nucleus","x":"*quasar","xSupp":"active_*galaxy_nucleus<X4>*quasar","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agns","nChars":"4","priority":"1","type":"jargon","tIndx":"active_*galaxy_nucleus","x":"*quasar","xSupp":"active_*galaxy_nucleus<X4>*quasar","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ao","nChars":"2","priority":"1","type":"jargon","tIndx":"adaptive_optics","x":"","xSupp":"adaptive_optics<X4>seeing|diffraction_limited|tip_tilt","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"alp","nChars":"3","priority":"1","type":"jargon","tIndx":"*alpha","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"adu","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"adus","nChars":"4","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dn","nChars":"2","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dns","nChars":"3","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"datanumber","nChars":"10","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"datanumbers","nChars":"11","priority":"1","type":"jargon","tIndx":"analog_digital_unit","x":"","xSupp":"analog_digital_unit<X4>charge_coupled_device|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"aips","nChars":"4","priority":"1","type":"jargon","tIndx":"astronomical_image_processing_system","x":"","xSupp":"astronomical_image_processing_system<X4>radio|data_reduction_processing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"aor","nChars":"3","priority":"1","type":"jargon","tIndx":"astronomical_observation_request","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agb","nChars":"3","priority":"1","type":"jargon","tIndx":"asymptotic_giant_branch_*star","x":"red_giant|mira_variable|*ohir_*star","xSupp":"asymptotic_giant_branch_*star<X4>circumstellar_envelope|maser_emission|thermal_pulse","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"agbs","nChars":"4","priority":"1","type":"jargon","tIndx":"asymptotic_giant_branch_*star","x":"red_giant|mira_variable|*ohir_*star","xSupp":"asymptotic_giant_branch_*star<X4>circumstellar_envelope|maser_emission|thermal_pulse","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcoefficient","nChars":"12","priority":"1","type":"jargon","tIndx":"*b_*einstein_*coefficient","x":"*a_*einstein_*coefficient","xSupp":"*b_*einstein_*coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcoefficients","nChars":"13","priority":"1","type":"jargon","tIndx":"*b_*einstein_*coefficient","x":"*a_*einstein_*coefficient","xSupp":"*b_*einstein_*coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcoeff","nChars":"6","priority":"1","type":"jargon","tIndx":"*b_*einstein_*coefficient","x":"*a_*einstein_*coefficient","xSupp":"*b_*einstein_*coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcoeffs","nChars":"7","priority":"1","type":"jargon","tIndx":"*b_*einstein_*coefficient","x":"*a_*einstein_*coefficient","xSupp":"*b_*einstein_*coefficient<X4>*a_einstein_coefficient","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bstar","nChars":"5","priority":"1","type":"jargon","tIndx":"*b_*star","x":"","xSupp":"*b_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bstars","nChars":"6","priority":"1","type":"jargon","tIndx":"*b_*star","x":"","xSupp":"*b_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"btypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*b_*star","x":"","xSupp":"*b_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"btypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*b_*star","x":"","xSupp":"*b_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"btype","nChars":"5","priority":"1","type":"jargon","tIndx":"*b_*star","x":"","xSupp":"*b_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"btypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*b_*star","x":"","xSupp":"*b_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"oandbstar","nChars":"9","priority":"1","type":"jargon","tIndx":"*b_*star|*o_star","x":"","xSupp":"*b_*star<X4>massive|main_sequence *o_star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"oandbstars","nChars":"10","priority":"1","type":"jargon","tIndx":"*b_*star|*o_star","x":"","xSupp":"*b_*star<X4>massive|main_sequence *o_star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"obassociation","nChars":"13","priority":"1","type":"jargon","tIndx":"*b_*star|*o_star","x":"","xSupp":"*b_*star<X4>massive|main_sequence *o_star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"obassociations","nChars":"14","priority":"1","type":"jargon","tIndx":"*b_*star|*o_star","x":"","xSupp":"*b_*star<X4>massive|main_sequence *o_star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"obstar","nChars":"6","priority":"1","type":"jargon","tIndx":"*b_*star|*o_star","x":"","xSupp":"*b_*star<X4>massive|main_sequence *o_star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"obstars","nChars":"7","priority":"1","type":"jargon","tIndx":"*b_*star|*o_star","x":"","xSupp":"*b_*star<X4>massive|main_sequence *o_star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ba","nChars":"2","priority":"1","type":"jargon","tIndx":"*balmer","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"balm","nChars":"4","priority":"1","type":"jargon","tIndx":"*balmer","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"balmers","nChars":"7","priority":"1","type":"jargon","tIndx":"*balmer","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bad","nChars":"3","priority":"1","type":"jargon","tIndx":"*balmer_absorption_dominated_nucleus_*galaxy","x":"post_*star_burst_*galaxy","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bads","nChars":"4","priority":"1","type":"jargon","tIndx":"*balmer_absorption_dominated_nucleus_*galaxy","x":"post_*star_burst_*galaxy","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bbg","nChars":"3","priority":"1","type":"jargon","tIndx":"*balmer_break_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bbgs","nChars":"4","priority":"1","type":"jargon","tIndx":"*balmer_break_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"beta","nChars":"4","priority":"1","type":"jargon","tIndx":"*beta","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bh","nChars":"2","priority":"1","type":"jargon","tIndx":"black_hole","x":"","xSupp":"black_hole<X4>active_galactic_nucleus|*o_*star|*b_star","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bhs","nChars":"3","priority":"1","type":"jargon","tIndx":"black_hole","x":"","xSupp":"black_hole<X4>active_galactic_nucleus|*o_*star|*b_star","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bhxrt","nChars":"5","priority":"1","type":"jargon","tIndx":"black_hole_*x_ray_transient","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bhxrts","nChars":"6","priority":"1","type":"jargon","tIndx":"black_hole_*x_ray_transient","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blazars","nChars":"7","priority":"1","type":"jargon","tIndx":"*blazar","x":"","xSupp":"*blazar<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bllac","nChars":"5","priority":"1","type":"jargon","tIndx":"*blazar","x":"","xSupp":"*blazar<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bll","nChars":"3","priority":"1","type":"jargon","tIndx":"*blazar","x":"","xSupp":"*blazar<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcd","nChars":"3","priority":"1","type":"jargon","tIndx":"blue_compact_dwarf_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcds","nChars":"4","priority":"1","type":"jargon","tIndx":"blue_compact_dwarf_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcg","nChars":"3","priority":"1","type":"jargon","tIndx":"blue_compact_*galaxy|brightest_cluster_galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bcgs","nChars":"4","priority":"1","type":"jargon","tIndx":"blue_compact_*galaxy|brightest_cluster_galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bluecg","nChars":"6","priority":"1","type":"jargon","tIndx":"blue_compact_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bhb","nChars":"3","priority":"1","type":"jargon","tIndx":"blue_horizontal_branch_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bhbs","nChars":"4","priority":"1","type":"jargon","tIndx":"blue_horizontal_branch_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bss","nChars":"3","priority":"1","type":"jargon","tIndx":"blue_straggler_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bsss","nChars":"4","priority":"1","type":"jargon","tIndx":"blue_straggler_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bsg","nChars":"3","priority":"1","type":"jargon","tIndx":"blue_*super_giant_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bsgs","nChars":"4","priority":"1","type":"jargon","tIndx":"blue_*super_giant_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bpt","nChars":"3","priority":"1","type":"jargon","tIndx":"*bpt_diagram","x":"","xSupp":"*bpt_diagram<X4>active_galactic_nucleus|*star_burst|spectral_diagnostics","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"baldwinphillipsandterlevich","nChars":"27","priority":"1","type":"jargon","tIndx":"*bpt_diagram","x":"","xSupp":"*bpt_diagram<X4>active_galactic_nucleus|*star_burst|spectral_diagnostics","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"baldwinphillipsterlevich","nChars":"24","priority":"1","type":"jargon","tIndx":"*bpt_diagram","x":"","xSupp":"*bpt_diagram<X4>active_galactic_nucleus|*star_burst|spectral_diagnostics","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"centraldominant","nChars":"15","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cdtype","nChars":"6","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"typecd","nChars":"6","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"supergiantelliptical","nChars":"20","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cD","nChars":"2","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"giantelliptical","nChars":"15","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"clusterdominant","nChars":"15","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"brightestcentralgalaxies","nChars":"24","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gE","nChars":"2","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gEs","nChars":"3","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dgalaxy","nChars":"7","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dgalaxies","nChars":"9","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"brightestcentralgalaxy","nChars":"22","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"supergiantellipticals","nChars":"21","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"giantellipticals","nChars":"16","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"brcig","nChars":"5","priority":"1","type":"jargon","tIndx":"brightest_cluster_*galaxy","x":"large_halo|extended_halo|extended_diffuse_envelope","xSupp":"brightest_cluster_*galaxy<X4>bright_elliptical|fossil_group|intra_cluster_light|galactic_cannibalism","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bal","nChars":"3","priority":"1","type":"jargon","tIndx":"broad_absorption_line_*galaxy","x":"","xSupp":"broad_absorption_line_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bel","nChars":"3","priority":"1","type":"jargon","tIndx":"broad_emission_line_*galaxy","x":"","xSupp":"broad_emission_line_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bels","nChars":"4","priority":"1","type":"jargon","tIndx":"broad_emission_line_*galaxy","x":"","xSupp":"broad_emission_line_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blagn","nChars":"5","priority":"1","type":"jargon","tIndx":"broad_line_active_galactic_nucleus","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blagns","nChars":"6","priority":"1","type":"jargon","tIndx":"broad_line_active_galactic_nucleus","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blr","nChars":"3","priority":"1","type":"jargon","tIndx":"broad_line_region","x":"","xSupp":"broad_line_region<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blrs","nChars":"4","priority":"1","type":"jargon","tIndx":"broad_line_region","x":"","xSupp":"broad_line_region<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blrg","nChars":"4","priority":"1","type":"jargon","tIndx":"broad_line_radio_*galaxy","x":"","xSupp":"broad_line_radio_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"blrgs","nChars":"5","priority":"1","type":"jargon","tIndx":"broad_line_radio_*galaxy","x":"","xSupp":"broad_line_radio_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cno","nChars":"3","priority":"1","type":"jargon","tIndx":"carbon_nitrogen_oxygen","x":"","xSupp":"carbon_nitrogen_oxygen<X4>*nucleosynthesis","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"centimeter","nChars":"10","priority":"1","type":"jargon","tIndx":"*centi_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"centimeters","nChars":"11","priority":"1","type":"jargon","tIndx":"*centi_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cm","nChars":"2","priority":"1","type":"jargon","tIndx":"*centi_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ccd","nChars":"3","priority":"1","type":"jargon","tIndx":"charge_coupled_device|color_diagram","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"circ","nChars":"4","priority":"1","type":"jargon","tIndx":"circular","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"circularvelocity","nChars":"16","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"rotationspeed","nChars":"13","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"rotationalspeed","nChars":"15","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"rotationvelocity","nChars":"16","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"rotationalvelocity","nChars":"18","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"circvelocity","nChars":"12","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"circspeed","nChars":"9","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"circularvel","nChars":"11","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"circvel","nChars":"7","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"angularvelocity","nChars":"15","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"angularvel","nChars":"10","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"angularspeed","nChars":"12","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"angvelocity","nChars":"11","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"angspeed","nChars":"8","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"vcircular","nChars":"9","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"vangular","nChars":"8","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"velcirc","nChars":"7","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"velangular","nChars":"10","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"rotvel","nChars":"6","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"rotv","nChars":"4","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"vcirc","nChars":"5","priority":"1","type":"jargon","tIndx":"circular_speed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmoss","nChars":"5","priority":"1","type":"jargon","tIndx":"*cmos","x":"","xSupp":"*cmos<X4>detector","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"complementarymetaloxidesemiconductor","nChars":"36","priority":"1","type":"jargon","tIndx":"*cmos","x":"","xSupp":"*cmos<X4>detector","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"coefficient","nChars":"11","priority":"1","type":"jargon","tIndx":"*coefficient","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"coefficients","nChars":"12","priority":"1","type":"jargon","tIndx":"*coefficient","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"coeff","nChars":"5","priority":"1","type":"jargon","tIndx":"*coefficient","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"coeffs","nChars":"6","priority":"1","type":"jargon","tIndx":"*coefficient","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cdm","nChars":"3","priority":"1","type":"jargon","tIndx":"cold_dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cdms","nChars":"4","priority":"1","type":"jargon","tIndx":"cold_dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ccds","nChars":"4","priority":"1","type":"jargon","tIndx":"color_diagram","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmd","nChars":"3","priority":"1","type":"jargon","tIndx":"color_magnitude_diagram","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmds","nChars":"4","priority":"1","type":"jargon","tIndx":"color_magnitude_diagram","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmdiagram","nChars":"9","priority":"1","type":"jargon","tIndx":"color_magnitude_diagram","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmdiagrams","nChars":"10","priority":"1","type":"jargon","tIndx":"color_magnitude_diagram","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cnelg","nChars":"5","priority":"1","type":"jargon","tIndx":"compact_narrow_emission_line_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cnelgs","nChars":"6","priority":"1","type":"jargon","tIndx":"compact_narrow_emission_line_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cgcs","nChars":"4","priority":"1","type":"jargon","tIndx":"cool_galactic_carbon_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cme","nChars":"3","priority":"1","type":"jargon","tIndx":"coronal_mass_ejection","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmes","nChars":"4","priority":"1","type":"jargon","tIndx":"coronal_mass_ejection","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cbr","nChars":"3","priority":"1","type":"jargon","tIndx":"cosmic_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cib","nChars":"3","priority":"1","type":"jargon","tIndx":"cosmic_*infrared_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cibr","nChars":"4","priority":"1","type":"jargon","tIndx":"cosmic_*infrared_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmb","nChars":"3","priority":"1","type":"jargon","tIndx":"cosmic_microwave_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cmbr","nChars":"4","priority":"1","type":"jargon","tIndx":"cosmic_microwave_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mbr","nChars":"3","priority":"1","type":"jargon","tIndx":"cosmic_microwave_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cnb","nChars":"3","priority":"1","type":"jargon","tIndx":"cosmic_neutrino_background","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cr","nChars":"2","priority":"1","type":"jargon","tIndx":"cosmic_ray","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cxbr","nChars":"4","priority":"1","type":"jargon","tIndx":"cosmic_*x_ray_background_radiation","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cpus","nChars":"4","priority":"1","type":"jargon","tIndx":"*cpu","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"centralprocessingunit","nChars":"21","priority":"1","type":"jargon","tIndx":"*cpu","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"centralprocessingunits","nChars":"22","priority":"1","type":"jargon","tIndx":"*cpu","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cog","nChars":"3","priority":"1","type":"jargon","tIndx":"curve_of_growth","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cogs","nChars":"4","priority":"1","type":"jargon","tIndx":"curve_of_growth","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dla","nChars":"3","priority":"1","type":"jargon","tIndx":"damped_*lyman_*alpha","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dlas","nChars":"4","priority":"1","type":"jargon","tIndx":"damped_*lyman_*alpha","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dlya","nChars":"4","priority":"1","type":"jargon","tIndx":"damped_*lyman_*alpha","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dlyas","nChars":"5","priority":"1","type":"jargon","tIndx":"damped_*lyman_*alpha","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dm","nChars":"2","priority":"1","type":"jargon","tIndx":"dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dms","nChars":"3","priority":"1","type":"jargon","tIndx":"dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dec","nChars":"3","priority":"1","type":"jargon","tIndx":"declination","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"deltas","nChars":"6","priority":"1","type":"jargon","tIndx":"*delta","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"del","nChars":"3","priority":"1","type":"jargon","tIndx":"*delta","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucouleur","nChars":"12","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucouleurs","nChars":"13","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucouleursr0\\.25","nChars":"18","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucouleursr1/4","nChars":"16","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucouleurr0\\.25","nChars":"17","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucouleurr1/4","nChars":"15","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucr0\\.25","nChars":"11","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"devaucr1/4","nChars":"9","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"r0\\.25","nChars":"5","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"r1/4","nChars":"3","priority":"1","type":"jargon","tIndx":"*devauc","x":"surface_brightness_profile|bulge","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dexs","nChars":"4","priority":"1","type":"jargon","tIndx":"*dex","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dexes","nChars":"5","priority":"1","type":"jargon","tIndx":"*dex","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dib","nChars":"3","priority":"1","type":"jargon","tIndx":"diffuse_interstellar_band","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dibs","nChars":"4","priority":"1","type":"jargon","tIndx":"diffuse_interstellar_band","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"cz","nChars":"2","priority":"1","type":"jargon","tIndx":"distance","x":"redshift|recessional_velocity","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dbgalaxy","nChars":"8","priority":"1","type":"jargon","tIndx":"dumbbell_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dbgalaxies","nChars":"10","priority":"1","type":"jargon","tIndx":"dumbbell_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"db","nChars":"2","priority":"1","type":"jargon","tIndx":"dumbbell_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dgs","nChars":"3","priority":"1","type":"jargon","tIndx":"dumbbell_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"doublegalaxy","nChars":"12","priority":"1","type":"jargon","tIndx":"dumbbell_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"doublegalaxies","nChars":"14","priority":"1","type":"jargon","tIndx":"dumbbell_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dog","nChars":"3","priority":"1","type":"jargon","tIndx":"dust_obscured_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dogs","nChars":"4","priority":"1","type":"jargon","tIndx":"dust_obscured_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dwf","nChars":"3","priority":"1","type":"jargon","tIndx":"dwarf","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dwfs","nChars":"4","priority":"1","type":"jargon","tIndx":"dwarf","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"dans","nChars":"4","priority":"1","type":"jargon","tIndx":"dwarf_amorphous_nuclear_*star_burst","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"effectiverad","nChars":"12","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"reff","nChars":"4","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"reffective","nChars":"10","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"effectiver","nChars":"10","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"effrad","nChars":"6","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"effradius","nChars":"9","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"radeff","nChars":"6","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"radeffective","nChars":"12","priority":"1","type":"jargon","tIndx":"effective|radius","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etg","nChars":"3","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etgs","nChars":"4","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"bulgedominated","nChars":"14","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etype","nChars":"5","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etypes","nChars":"6","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etypegalaxy","nChars":"11","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etypegalaxies","nChars":"13","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"etypegalaxys","nChars":"12","priority":"1","type":"jargon","tIndx":"early_type_*galaxy","x":"elliptical|lenticular","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ell","nChars":"3","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ells","nChars":"4","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ellgalaxy","nChars":"9","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ellgalaxies","nChars":"11","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ellgalaxys","nChars":"10","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"elliptical","nChars":"10","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ellipticals","nChars":"11","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e7","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e6","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e5","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e4","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e3","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e2","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e1","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"e0","nChars":"2","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ellipt","nChars":"6","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ellipts","nChars":"7","priority":"1","type":"jargon","tIndx":"elliptical_*galaxy","x":"early_type","xSupp":"elliptical_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ew","nChars":"2","priority":"1","type":"jargon","tIndx":"equivalent_width","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ews","nChars":"3","priority":"1","type":"jargon","tIndx":"equivalent_width","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"egg","nChars":"3","priority":"1","type":"jargon","tIndx":"evaporation_gaseous_globule","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"eggs","nChars":"4","priority":"1","type":"jargon","tIndx":"evaporation_gaseous_globule","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ehb","nChars":"3","priority":"1","type":"jargon","tIndx":"extreme_horizontal_branch_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ehbs","nChars":"4","priority":"1","type":"jargon","tIndx":"extreme_horizontal_branch_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"elf","nChars":"3","priority":"1","type":"jargon","tIndx":"extremely_luminous_far_*infrared_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"elfs","nChars":"4","priority":"1","type":"jargon","tIndx":"extremely_luminous_far_*infrared_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ultraelf","nChars":"8","priority":"1","type":"jargon","tIndx":"extremely_luminous_far_*infrared_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"xmpg","nChars":"4","priority":"1","type":"jargon","tIndx":"extremely_metal_poor_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"xmpgs","nChars":"5","priority":"1","type":"jargon","tIndx":"extremely_metal_poor_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ero","nChars":"3","priority":"1","type":"jargon","tIndx":"extremely_red_object_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"eros","nChars":"4","priority":"1","type":"jargon","tIndx":"extremely_red_object_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"euv","nChars":"3","priority":"1","type":"jargon","tIndx":"extreme_*ultraviolet","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ETC","nChars":"3","priority":"1","type":"jargon","tIndx":"exposure_time_calculator","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fstar","nChars":"5","priority":"1","type":"jargon","tIndx":"*f_*star","x":"","xSupp":"*f_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fstars","nChars":"6","priority":"1","type":"jargon","tIndx":"*f_*star","x":"","xSupp":"*f_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ftypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*f_*star","x":"","xSupp":"*f_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ftypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*f_*star","x":"","xSupp":"*f_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ftype","nChars":"5","priority":"1","type":"jargon","tIndx":"*f_*star","x":"","xSupp":"*f_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ftypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*f_*star","x":"","xSupp":"*f_*star<X4>intermediate_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fir","nChars":"3","priority":"1","type":"jargon","tIndx":"far_*infrared","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fuv","nChars":"3","priority":"1","type":"jargon","tIndx":"far_*ultraviolet","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fft","nChars":"3","priority":"1","type":"jargon","tIndx":"fast_*fourier_transform","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ffts","nChars":"4","priority":"1","type":"jargon","tIndx":"fast_*fourier_transform_spectrometer","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fov","nChars":"3","priority":"1","type":"jargon","tIndx":"field_of_view","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"flambda","nChars":"7","priority":"1","type":"jargon","tIndx":"flux","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"frb","nChars":"3","priority":"1","type":"jargon","tIndx":"fast_radio_burst","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"frbs","nChars":"4","priority":"1","type":"jargon","tIndx":"fast_radio_burst","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fred","nChars":"4","priority":"1","type":"jargon","tIndx":"fast_rise_exponential_decay","x":"","xSupp":"fast_rise_exponential_decay<X4>*gamma_ray","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fsrq","nChars":"4","priority":"1","type":"jargon","tIndx":"flat_spectrum_radio_*quasar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fwhm","nChars":"4","priority":"1","type":"jargon","tIndx":"full_width_half_maximum","x":"resolution|seeing|full_width_zero_intensity","xSupp":"full_width_half_maximum<X4>resolution|seeing|full_width_zero_intensity","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fwzi","nChars":"4","priority":"1","type":"jargon","tIndx":"full_width_zero_intensity","x":"resolution|seeing","xSupp":"full_width_zero_intensity<X4>resolution|seeing","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"galactic","nChars":"8","priority":"1","type":"jargon","tIndx":"*milky_way_*galaxy","x":"*g_*star","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gcr","nChars":"3","priority":"1","type":"jargon","tIndx":"galactic_cosmic_ray","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gcrs","nChars":"4","priority":"1","type":"jargon","tIndx":"galactic_cosmic_ray","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gmf","nChars":"3","priority":"1","type":"jargon","tIndx":"galactic_magnetic_field","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gmfs","nChars":"4","priority":"1","type":"jargon","tIndx":"galactic_magnetic_field","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gamma","nChars":"5","priority":"1","type":"jargon","tIndx":"*gamma","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gam","nChars":"3","priority":"1","type":"jargon","tIndx":"*gamma","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gray","nChars":"4","priority":"1","type":"jargon","tIndx":"*gamma_ray","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"grays","nChars":"5","priority":"1","type":"jargon","tIndx":"*gamma_ray","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"giga","nChars":"4","priority":"1","type":"jargon","tIndx":"*giga","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gig","nChars":"3","priority":"1","type":"jargon","tIndx":"*giga","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ghz","nChars":"3","priority":"1","type":"jargon","tIndx":"*giga_*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gps","nChars":"3","priority":"1","type":"jargon","tIndx":"*giga_*hertz_peaked_spectrum","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gpss","nChars":"4","priority":"1","type":"jargon","tIndx":"*giga_*hertz_peaked_spectrum","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gmc","nChars":"3","priority":"1","type":"jargon","tIndx":"giant_molecular_cloud","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gmcs","nChars":"4","priority":"1","type":"jargon","tIndx":"giant_molecular_cloud","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gimp","nChars":"4","priority":"1","type":"jargon","tIndx":"gravitationally_interacting_massive_particle","x":"","xSupp":"gravitationally_interacting_massive_particle<X4>dark_matter","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"gimps","nChars":"5","priority":"1","type":"jargon","tIndx":"gravitationally_interacting_massive_particle","x":"","xSupp":"gravitationally_interacting_massive_particle<X4>dark_matter","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"grp","nChars":"3","priority":"1","type":"jargon","tIndx":"group","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"grps","nChars":"4","priority":"1","type":"jargon","tIndx":"group","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hertz","nChars":"5","priority":"1","type":"jargon","tIndx":"*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hertzs","nChars":"6","priority":"1","type":"jargon","tIndx":"*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hz","nChars":"2","priority":"1","type":"jargon","tIndx":"*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hzs","nChars":"3","priority":"1","type":"jargon","tIndx":"*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"heg","nChars":"3","priority":"1","type":"jargon","tIndx":"high_excitation_*galaxy","x":"","xSupp":"high_excitation_*galaxy<X4>radio_galaxy|low_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hegs","nChars":"4","priority":"1","type":"jargon","tIndx":"high_excitation_*galaxy","x":"","xSupp":"high_excitation_*galaxy<X4>radio_galaxy|low_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hex","nChars":"3","priority":"1","type":"jargon","tIndx":"high_excitation_*galaxy","x":"","xSupp":"high_excitation_*galaxy<X4>radio_galaxy|low_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hexs","nChars":"4","priority":"1","type":"jargon","tIndx":"high_excitation_*galaxy","x":"","xSupp":"high_excitation_*galaxy<X4>radio_galaxy|low_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hpq","nChars":"3","priority":"1","type":"jargon","tIndx":"high_polarization_*quasar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hpqs","nChars":"4","priority":"1","type":"jargon","tIndx":"high_polarization_*quasar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hpquasar","nChars":"8","priority":"1","type":"jargon","tIndx":"high_polarization_*quasar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hpquasars","nChars":"9","priority":"1","type":"jargon","tIndx":"high_polarization_*quasar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hbrp","nChars":"4","priority":"1","type":"jargon","tIndx":"high_magnetic_field_radio_*pulsar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hbrps","nChars":"5","priority":"1","type":"jargon","tIndx":"high_magnetic_field_radio_*pulsar","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hmpo","nChars":"4","priority":"1","type":"jargon","tIndx":"high_mass_*proto_stellar_object","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hmpos","nChars":"5","priority":"1","type":"jargon","tIndx":"high_mass_*proto_stellar_object","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hmxb","nChars":"4","priority":"1","type":"jargon","tIndx":"high_mass_*x_ray_binary_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hmxbs","nChars":"5","priority":"1","type":"jargon","tIndx":"high_mass_*x_ray_binary_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hsb","nChars":"3","priority":"1","type":"jargon","tIndx":"high_surface_brightness","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hvc","nChars":"3","priority":"1","type":"jargon","tIndx":"high_velocity_cloud","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hvcs","nChars":"4","priority":"1","type":"jargon","tIndx":"high_velocity_cloud","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hb","nChars":"2","priority":"1","type":"jargon","tIndx":"horizontal_branch_*star","x":"","xSupp":"horizontal_branch_*star<X4>red_giant_star","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hbs","nChars":"3","priority":"1","type":"jargon","tIndx":"horizontal_branch_*star","x":"","xSupp":"horizontal_branch_*star<X4>red_giant_star","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hdm","nChars":"3","priority":"1","type":"jargon","tIndx":"hot_dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hdms","nChars":"4","priority":"1","type":"jargon","tIndx":"hot_dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hertzsprungrusselldiagram","nChars":"25","priority":"1","type":"jargon","tIndx":"*hr_diagram","x":"stellar_evolution","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hertzsprungrusselldiagrams","nChars":"26","priority":"1","type":"jargon","tIndx":"*hr_diagram","x":"stellar_evolution","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hertzsprungrussell","nChars":"18","priority":"1","type":"jargon","tIndx":"*hr_diagram","x":"stellar_evolution","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"h0","nChars":"2","priority":"1","type":"jargon","tIndx":"*hubble_constant","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hubblesconstant","nChars":"15","priority":"1","type":"jargon","tIndx":"*hubble_constant","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hlirg","nChars":"5","priority":"1","type":"jargon","tIndx":"*hyper_luminous_*infrared_*galaxy","x":"*star_burst","xSupp":"*hyper_luminous_*infrared_*galaxy<X4>*star_burst","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hlirgs","nChars":"6","priority":"1","type":"jargon","tIndx":"*hyper_luminous_*infrared_*galaxy","x":"*star_burst","xSupp":"*hyper_luminous_*infrared_*galaxy<X4>*star_burst","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"d025","nChars":"4","priority":"1","type":"jargon","tIndx":"inclination_corrected_isophotal_diameter","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ir","nChars":"2","priority":"1","type":"jargon","tIndx":"*infrared","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"irdc","nChars":"4","priority":"1","type":"jargon","tIndx":"*infrared_dark_cloud","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"irdcs","nChars":"5","priority":"1","type":"jargon","tIndx":"*infrared_dark_cloud","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"irx","nChars":"3","priority":"1","type":"jargon","tIndx":"*infrared_excess","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"imf","nChars":"3","priority":"1","type":"jargon","tIndx":"initial_mass_function","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"imfs","nChars":"4","priority":"1","type":"jargon","tIndx":"initial_mass_function","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ifs","nChars":"3","priority":"1","type":"jargon","tIndx":"*INTEGRAL_field_spectroscopy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ifsu","nChars":"4","priority":"1","type":"jargon","tIndx":"*INTEGRAL_field_spectroscopy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ifsus","nChars":"5","priority":"1","type":"jargon","tIndx":"*INTEGRAL_field_spectroscopy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ised","nChars":"4","priority":"1","type":"jargon","tIndx":"integrated_spectral_energy_distribution","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"iseds","nChars":"5","priority":"1","type":"jargon","tIndx":"integrated_spectral_energy_distribution","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"icm","nChars":"3","priority":"1","type":"jargon","tIndx":"*inter_galactic_cluster_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"icms","nChars":"4","priority":"1","type":"jargon","tIndx":"*inter_galactic_cluster_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"igm","nChars":"3","priority":"1","type":"jargon","tIndx":"*inter_galactic_cluster_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"igms","nChars":"4","priority":"1","type":"jargon","tIndx":"*inter_galactic_cluster_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"icmedium","nChars":"8","priority":"1","type":"jargon","tIndx":"*inter_galactic_cluster_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"igmedium","nChars":"8","priority":"1","type":"jargon","tIndx":"*inter_galactic_cluster_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ism","nChars":"3","priority":"1","type":"jargon","tIndx":"*inter_stellar_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"isms","nChars":"4","priority":"1","type":"jargon","tIndx":"*inter_stellar_medium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"irr","nChars":"3","priority":"1","type":"jargon","tIndx":"irregular_*galaxy","x":"late_type","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"irrs","nChars":"4","priority":"1","type":"jargon","tIndx":"irregular_*galaxy","x":"late_type","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ieg","nChars":"3","priority":"1","type":"jargon","tIndx":"isolated_early_type_*galaxy|isolated_elliptical_galaxy|isolated_lenticular_galaxy","x":"void_*galaxy|fossil_group","xSupp":"isolated_early_type_*galaxy|isolated_elliptical_galaxy|isolated_lenticular_galaxy<X4>field_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"iegs","nChars":"4","priority":"1","type":"jargon","tIndx":"isolated_early_type_*galaxy|isolated_elliptical_galaxy|isolated_lenticular_galaxy","x":"void_*galaxy|fossil_group","xSupp":"isolated_early_type_*galaxy|isolated_elliptical_galaxy|isolated_lenticular_galaxy<X4>field_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"d25","nChars":"3","priority":"1","type":"jargon","tIndx":"isophotal_diameter","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mu25","nChars":"4","priority":"1","type":"jargon","tIndx":"isophotal_diameter","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mub25","nChars":"5","priority":"1","type":"jargon","tIndx":"isophotal_diameter_*visible","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mupg","nChars":"4","priority":"1","type":"jargon","tIndx":"isophotal_diameter_*visible","x":"*galaxy_diameter|galaxy_size","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"r25","nChars":"3","priority":"1","type":"jargon","tIndx":"isophotal_ratio","x":"*galaxy_eccentricity|galaxy_ellipticity","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"kstar","nChars":"5","priority":"1","type":"jargon","tIndx":"*k_*star","x":"","xSupp":"*k_*star<X4>solar_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"kstars","nChars":"6","priority":"1","type":"jargon","tIndx":"*k_*star","x":"","xSupp":"*k_*star<X4>solar_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ktypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*k_*star","x":"","xSupp":"*k_*star<X4>solar_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ktypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*k_*star","x":"","xSupp":"*k_*star<X4>solar_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ktype","nChars":"5","priority":"1","type":"jargon","tIndx":"*k_*star","x":"","xSupp":"*k_*star<X4>solar_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ktypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*k_*star","x":"","xSupp":"*k_*star<X4>solar_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"kilohertz","nChars":"9","priority":"1","type":"jargon","tIndx":"*kilo_*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"khz","nChars":"3","priority":"1","type":"jargon","tIndx":"*kilo_*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"kev","nChars":"3","priority":"1","type":"jargon","tIndx":"*kilo_electron_volt","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lcdm","nChars":"4","priority":"1","type":"jargon","tIndx":"*lambda_cold_dark_matter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lmc","nChars":"3","priority":"1","type":"jargon","tIndx":"large_*magellanic_cloud_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lenticular","nChars":"10","priority":"1","type":"jargon","tIndx":"lenticular_*galaxy","x":"early_type","xSupp":"lenticular_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lenticulars","nChars":"11","priority":"1","type":"jargon","tIndx":"lenticular_*galaxy","x":"early_type","xSupp":"lenticular_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"s0","nChars":"2","priority":"1","type":"jargon","tIndx":"lenticular_*galaxy","x":"early_type","xSupp":"lenticular_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"s0s","nChars":"3","priority":"1","type":"jargon","tIndx":"lenticular_*galaxy","x":"early_type","xSupp":"lenticular_*galaxy<X4>early_type","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lte","nChars":"3","priority":"1","type":"jargon","tIndx":"local_thermodynamic_equilibrium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lpv","nChars":"3","priority":"1","type":"jargon","tIndx":"long_period_variable_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lpvs","nChars":"4","priority":"1","type":"jargon","tIndx":"long_period_variable_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"leg","nChars":"3","priority":"1","type":"jargon","tIndx":"low_excitation_*galaxy","x":"","xSupp":"low_excitation_*galaxy<X4>radio_galaxy|high_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lerg","nChars":"4","priority":"1","type":"jargon","tIndx":"low_excitation_*galaxy","x":"","xSupp":"low_excitation_*galaxy<X4>radio_galaxy|high_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lex","nChars":"3","priority":"1","type":"jargon","tIndx":"low_excitation_*galaxy","x":"","xSupp":"low_excitation_*galaxy<X4>radio_galaxy|high_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lexs","nChars":"4","priority":"1","type":"jargon","tIndx":"low_excitation_*galaxy","x":"","xSupp":"low_excitation_*galaxy<X4>radio_galaxy|high_excitation_galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"liner","nChars":"5","priority":"1","type":"jargon","tIndx":"low_ionization_nuclear_emission_region","x":"","xSupp":"low_ionization_nuclear_emission_region<X4>active_galactic_nuclei","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"liners","nChars":"6","priority":"1","type":"jargon","tIndx":"low_ionization_nuclear_emission_region","x":"","xSupp":"low_ionization_nuclear_emission_region<X4>active_galactic_nuclei","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"llagn","nChars":"5","priority":"1","type":"jargon","tIndx":"low_luminosity_active_galactic_nucleus","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"llagns","nChars":"6","priority":"1","type":"jargon","tIndx":"low_luminosity_active_galactic_nucleus","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lmxb","nChars":"4","priority":"1","type":"jargon","tIndx":"low_mass_*x_ray_binary_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lmxbs","nChars":"5","priority":"1","type":"jargon","tIndx":"low_mass_*x_ray_binary_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lpq","nChars":"3","priority":"1","type":"jargon","tIndx":"low_polarization_*quasar","x":"","xSupp":"low_polarization_*quasar<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lpqs","nChars":"4","priority":"1","type":"jargon","tIndx":"low_polarization_*quasar","x":"","xSupp":"low_polarization_*quasar<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lsb","nChars":"3","priority":"1","type":"jargon","tIndx":"low_surface_brightness","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lms","nChars":"3","priority":"1","type":"jargon","tIndx":"lower_main_sequence_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lbcg","nChars":"4","priority":"1","type":"jargon","tIndx":"luminous_blue_compact_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lbcgs","nChars":"5","priority":"1","type":"jargon","tIndx":"luminous_blue_compact_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lbv","nChars":"3","priority":"1","type":"jargon","tIndx":"luminous_blue_variable_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lbvs","nChars":"4","priority":"1","type":"jargon","tIndx":"luminous_blue_variable_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lirg","nChars":"4","priority":"1","type":"jargon","tIndx":"luminous_*infrared_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lirgs","nChars":"5","priority":"1","type":"jargon","tIndx":"luminous_*infrared_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lf","nChars":"2","priority":"1","type":"jargon","tIndx":"luminosity_function","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lfs","nChars":"3","priority":"1","type":"jargon","tIndx":"luminosity_function","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lrg","nChars":"3","priority":"1","type":"jargon","tIndx":"luminous_red_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lrgs","nChars":"4","priority":"1","type":"jargon","tIndx":"luminous_red_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lyman","nChars":"5","priority":"1","type":"jargon","tIndx":"*lyman","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lymans","nChars":"6","priority":"1","type":"jargon","tIndx":"*lyman","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ly","nChars":"2","priority":"1","type":"jargon","tIndx":"*lyman","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lae","nChars":"3","priority":"1","type":"jargon","tIndx":"*lyman_*alpha_emitter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"laes","nChars":"4","priority":"1","type":"jargon","tIndx":"*lyman_*alpha_emitter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lbg","nChars":"3","priority":"1","type":"jargon","tIndx":"*lyman_break_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lbgs","nChars":"4","priority":"1","type":"jargon","tIndx":"*lyman_break_*galaxy","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mstar","nChars":"5","priority":"1","type":"jargon","tIndx":"*m_*star","x":"","xSupp":"*m_*star<X4>low_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mstars","nChars":"6","priority":"1","type":"jargon","tIndx":"*m_*star","x":"","xSupp":"*m_*star<X4>low_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mtypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*m_*star","x":"","xSupp":"*m_*star<X4>low_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mtypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*m_*star","x":"","xSupp":"*m_*star<X4>low_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mtype","nChars":"5","priority":"1","type":"jargon","tIndx":"*m_*star","x":"","xSupp":"*m_*star<X4>low_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mtypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*m_*star","x":"","xSupp":"*m_*star<X4>low_mass|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"andromedagalaxy","nChars":"15","priority":"1","type":"jargon","tIndx":"*m31","x":"","xSupp":"*m31<X4>local_group_*galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"messier31","nChars":"9","priority":"1","type":"jargon","tIndx":"*m31","x":"","xSupp":"*m31<X4>local_group_*galaxy","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"magellanic","nChars":"10","priority":"1","type":"jargon","tIndx":"*magellanic","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mwd","nChars":"3","priority":"1","type":"jargon","tIndx":"magnetic_white_dwarf","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mwds","nChars":"4","priority":"1","type":"jargon","tIndx":"magnetic_white_dwarf","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mhd","nChars":"3","priority":"1","type":"jargon","tIndx":"magnetohydrodynamics","x":"","xSupp":"magnetohydrodynamics<X4>dynamics|magnetic","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mri","nChars":"3","priority":"1","type":"jargon","tIndx":"magnetorotational|instability","x":"accretion_disk","xSupp":"magnetorotational|instability<X4>dynamics|magnetic|rotation","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mlambda","nChars":"7","priority":"1","type":"jargon","tIndx":"magnitude","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mlam","nChars":"4","priority":"1","type":"jargon","tIndx":"magnitude","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ms","nChars":"2","priority":"1","type":"jargon","tIndx":"main_sequence","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mainseq","nChars":"7","priority":"1","type":"jargon","tIndx":"main_sequence","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"msolarlsolar","nChars":"12","priority":"1","type":"jargon","tIndx":"mass_to_light_ratio","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"msollsol","nChars":"8","priority":"1","type":"jargon","tIndx":"mass_to_light_ratio","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"msunlsun","nChars":"8","priority":"1","type":"jargon","tIndx":"mass_to_light_ratio","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mbh","nChars":"3","priority":"1","type":"jargon","tIndx":"massive_black_hole","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mbhs","nChars":"4","priority":"1","type":"jargon","tIndx":"massive_black_hole","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mxrb","nChars":"4","priority":"1","type":"jargon","tIndx":"massive_*x_ray_binary_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mxrbs","nChars":"5","priority":"1","type":"jargon","tIndx":"massive_*x_ray_binary_*star","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"myso","nChars":"4","priority":"1","type":"jargon","tIndx":"massive_young_stellar_object","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mysos","nChars":"5","priority":"1","type":"jargon","tIndx":"massive_young_stellar_object","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mhz","nChars":"3","priority":"1","type":"jargon","tIndx":"*mega_*hertz","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"micrometer","nChars":"10","priority":"1","type":"jargon","tIndx":"*micro_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"micrometers","nChars":"11","priority":"1","type":"jargon","tIndx":"*micro_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"microns","nChars":"7","priority":"1","type":"jargon","tIndx":"*micro_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"um","nChars":"2","priority":"1","type":"jargon","tIndx":"*micro_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mum","nChars":"3","priority":"1","type":"jargon","tIndx":"*micro_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"midir","nChars":"5","priority":"1","type":"jargon","tIndx":"*mid_*infrared","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mir","nChars":"3","priority":"1","type":"jargon","tIndx":"*mid_*infrared","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"miduv","nChars":"5","priority":"1","type":"jargon","tIndx":"*mid_*ultraviolet","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"muv","nChars":"3","priority":"1","type":"jargon","tIndx":"*mid_*ultraviolet","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mw","nChars":"2","priority":"1","type":"jargon","tIndx":"*milky_way_*galaxy","x":"local_group","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"millimeter","nChars":"10","priority":"1","type":"jargon","tIndx":"*milli_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"millimeters","nChars":"11","priority":"1","type":"jargon","tIndx":"*milli_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mm","nChars":"2","priority":"1","type":"jargon","tIndx":"*milli_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mond","nChars":"4","priority":"1","type":"jargon","tIndx":"modified_newtonian_dynamics","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"monds","nChars":"5","priority":"1","type":"jargon","tIndx":"modified_newtonian_dynamics","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fh2","nChars":"3","priority":"1","type":"jargon","tIndx":"molecular_hydrogen_flux","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mh2","nChars":"3","priority":"1","type":"jargon","tIndx":"molecular_hydrogen_mass","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nelg","nChars":"4","priority":"1","type":"jargon","tIndx":"narrow_emission_line_active_galactic_nucleus","x":"narrow_line_*galaxy","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nelgs","nChars":"5","priority":"1","type":"jargon","tIndx":"narrow_emission_line_active_galactic_nucleus","x":"narrow_line_*galaxy","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlagn","nChars":"5","priority":"1","type":"jargon","tIndx":"narrow_emission_line_active_galactic_nucleus","x":"narrow_line_*galaxy","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlagns","nChars":"6","priority":"1","type":"jargon","tIndx":"narrow_emission_line_active_galactic_nucleus","x":"narrow_line_*galaxy","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nanometer","nChars":"9","priority":"1","type":"jargon","tIndx":"*nano_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nanometers","nChars":"10","priority":"1","type":"jargon","tIndx":"*nano_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nm","nChars":"2","priority":"1","type":"jargon","tIndx":"*nano_meter","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlrg","nChars":"4","priority":"1","type":"jargon","tIndx":"narrow_line_radio_*galaxy","x":"narrow_line_*galaxy","xSupp":"narrow_line_radio_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlrgs","nChars":"5","priority":"1","type":"jargon","tIndx":"narrow_line_radio_*galaxy","x":"narrow_line_*galaxy","xSupp":"narrow_line_radio_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlsy1","nChars":"5","priority":"1","type":"jargon","tIndx":"narrow_line_seyfert_*galaxy","x":"narrow_line_*galaxy","xSupp":"narrow_line_seyfert_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlsy1s","nChars":"6","priority":"1","type":"jargon","tIndx":"narrow_line_seyfert_*galaxy","x":"narrow_line_*galaxy","xSupp":"narrow_line_seyfert_*galaxy<X4>active_galactic_nucleus","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nbody","nChars":"5","priority":"1","type":"jargon","tIndx":"*nbody","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"neo","nChars":"3","priority":"1","type":"jargon","tIndx":"near_earth_object","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"neos","nChars":"4","priority":"1","type":"jargon","tIndx":"near_earth_object","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nir","nChars":"3","priority":"1","type":"jargon","tIndx":"near_*infrared","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nearir","nChars":"6","priority":"1","type":"jargon","tIndx":"near_*infrared","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nuv","nChars":"3","priority":"1","type":"jargon","tIndx":"near_*ultraviolet","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nearuv","nChars":"6","priority":"1","type":"jargon","tIndx":"near_*ultraviolet","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"f21","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_flux","x":"*HI21cm","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"f21cm","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_flux","x":"*HI21cm","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fhi21","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_flux","x":"*HI21cm","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"fhi21cm","nChars":"7","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_flux","x":"*HI21cm","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"l21","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_luminosity","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"l21cm","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_luminosity","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lhi21","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_luminosity","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"lhi21cm","nChars":"7","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_luminosity","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"m21","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_mass","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mhi","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_mass","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"mhi21","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_mass","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"m21cm","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_mass","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"w10","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_profile_width","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"w50","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_profile_width","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"w80","nChars":"3","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_profile_width","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hisa","nChars":"4","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_self_absorption","x":"cold_atomic_phase|cold_interstellar_medium","xSupp":"neutral_hydrogen_self_absorption<X4>cold_atomic_phase|cold_interstellar_medium","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"hisas","nChars":"5","priority":"1","type":"jargon","tIndx":"neutral_hydrogen_self_absorption","x":"cold_atomic_phase|cold_interstellar_medium","xSupp":"neutral_hydrogen_self_absorption<X4>cold_atomic_phase|cold_interstellar_medium","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nlte","nChars":"4","priority":"1","type":"jargon","tIndx":"*non_local_thermodynamic_equilibrium","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nova","nChars":"4","priority":"1","type":"jargon","tIndx":"*nova","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"novas","nChars":"5","priority":"1","type":"jargon","tIndx":"*nova","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"novae","nChars":"5","priority":"1","type":"jargon","tIndx":"*nova","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"novaes","nChars":"6","priority":"1","type":"jargon","tIndx":"*nova","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"nucleosynthesis","nChars":"15","priority":"1","type":"jargon","tIndx":"*nucleosynthesis","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ostar","nChars":"5","priority":"1","type":"jargon","tIndx":"*o_*star","x":"","xSupp":"*o_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"ostars","nChars":"6","priority":"1","type":"jargon","tIndx":"*o_*star","x":"","xSupp":"*o_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"otypestar","nChars":"9","priority":"1","type":"jargon","tIndx":"*o_*star","x":"","xSupp":"*o_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"otypestars","nChars":"10","priority":"1","type":"jargon","tIndx":"*o_*star","x":"","xSupp":"*o_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"otype","nChars":"5","priority":"1","type":"jargon","tIndx":"*o_*star","x":"","xSupp":"*o_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"otypes","nChars":"6","priority":"1","type":"jargon","tIndx":"*o_*star","x":"","xSupp":"*o_*star<X4>massive|main_sequence","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"},{"reg":"obs","nChars":"3","priority":"1","type":"jargon","tIndx":"observed","x":"","xSupp":"","indx":"function(text, startPos) {\n               this.endMatch = \"-1\";\n               var m;\n               var t = JSON.parse(filterTheText(this.reg, text.slice(startPos)));\n// if the word explicitly contains capitalized letters, then any match must also have those\n// capital letters.  If the word has lower case letters, the match can have the first\n// letter captialized if it is at the beginning of a sentence, otherwise no match.\n               if (this.reg.match(/[A-Z]/)) {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'));\n               } else {\n                 m = t[0].match(new RegExp('^(?:'+this.reg+')'),'i'); }\n               var endMatch = -1;\n               var rightTst = false;\n               var leftTst = false;\n               var middleTst = true;\n               var capTst = true;\n               if (m) {\n                 endMatch = t[1][m[0].length-1] + 1 + startPos;\n// if there is a match, but if one more letter had been considered in the text, one would have retrieved the\n// word to be indexed, then allow that one additional word to be included in the match. For example,\n// the British spelling is \"distil\" and Americal spelling is \"distill\", and the text has \"distill\", would\n// want to avoid situation in which the \"distil\" is replaced with \"distill\", resulting in the erroneous \"distilll\":\n                 if (endMatch < t[0].length && this.tIndx == text.slice(startPos,endMatch+1)) {endMatch = endMatch + 1;}\n                 leftTst = true;\n                 rightTst = true;\n//// make sure that this is not a false-positive:  if the word is less than 5 characters long,\n//// insure that there is a non-alphanumeric character on the right and left side of it in\n//// the unfiltered version of the text.\n               ////  if (m[0].length <= 5 && startPos > 0 && text.charAt(startPos-1).match(/[^A-Za-z0-9]/)) {\n               ////    leftTst = true;}\n              ////   if (startPos == 0) {leftTst = true;}\n              ////   if (m[0].length > 5) {leftTst = true;}\n             ////    if (m[0].length <= 5 && text.length >= endMatch+1 && text.charAt(endMatch).match(/[^A-Za-z0-9]/)) {\n              ////     rightTst = true; }\n              ////   if (text.length < endMatch+1) {rightTst = true;}\n              ////   if (m[0].length > 5) {rightTst = true;}\n                if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/[A-Z]/).length > 1) {capTst = false;}\n                 if (this.reg.match(/[^A-Z]/) && m[0].match(/[A-Z]/) && m[0].match(/^[a-z0-9]/)) {capTst = false;}\n// Now check the characters between the first and last matched character to see if there is evidence\n// of sentence breaks and other characters that should not appear in the middle of real words:\n                 if (text.slice(startPos, endMatch).match(/\\. +[A-Z]/) && (!(m[0].match(/\\. +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\;/) && (!(m[0].match(/\\; +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\,/) && (!(m[0].match(/\\, +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\:/) && (!(m[0].match(/\\: +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\?/) && (!(m[0].match(/\\? +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\!/) && (!(m[0].match(/\\! +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\(/) && (!(m[0].match(/\\( +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\)/) && (!(m[0].match(/\\) +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\[/) && (!(m[0].match(/\\[ +[A-Z]/)))) {middleTst = false;}\n                 if (text.slice(startPos, endMatch).match(/\\]/) && (!(m[0].match(/\\] +[A-Z]/)))) {middleTst = false;}\n               }\n// Note that we don't test for curly brackets, as they may be present as part of latex markup\n// If all the tests come back OK, then we've got a legit match:\n               if (!(leftTst*rightTst*middleTst*capTst)) {return \"\"; }\n               this.endMatch = \"\"+endMatch;\n               return this.tIndx;}"}]